\chapter*{Resumen}

El objetivo de este trabajo es estudiar y presentar el algoritmo de Peterson-Gorenstein-Zierler para códigos cíclicos sesgados.  

\chapter*{Summary}

The main objetive of this project is to present, study and implement the Peterson-Gorenstein-Zierler algorithm for Skew Cyclic Codes.

\paragraph{Chapter 1} This chapter, sets the foundations of mathematic knowledge that's needed to understand the latter parts of the project. Skew Cyclic Codes require knowledge of two concepts: Ore Polynomial Rings and Cyclic Codes. On the one hand, Ore Polynomial Rings require the theory of Rings and Field Automorphisms. On the other hand, Cyclic Codes require the theory of Finite Fields and Rings. We introduce all the concepts needed.

\paragraph{Chapter 2} In this chapter, we introduce the concept of a code and the most studied class of codes: linear codes.
We also explain that linear codes over a finite field are just a vector subspace, so they conform to a mathematical structure that is well known and easy to study.
The elements in a code are called codewords.
We also use this chapter to introduce some concepts that we will refer to throughout the project and that are fundamental to the further development of coding theory.
To that extent, we present the definition of a generator matrix: a base of the vector subspace that a linear code ultimately is.
As we shall see, this matrix is fundamental in the most common procedure of message encoding.
Another important concept is the distance of a code, that is, the minimum number of coordinates that differentiate one codeword from another.
Finally, some simple families of codes are presented, such as repetition codes or Hamming codes.


\paragraph{Chapter 3} In this chapter, we shift our focus to the class of Cyclic Codes. 
As the name may suggest, these codes have the interesting property that cyclic shifts of codewords are also codewords of said code.
We'll see that codewords of these kinds of codes can be mapped to certain polynomials, and cyclic codes are simply the ideals of a polynomial ring quotient over the ideal generated by the polynomial \(x^n - 1\).
That's why we dedicate the first part of this chapter to the study of the factorization of this polynomial on polynomial rings over finite fields.
Once we know how to do this, we can properly describe all cyclic codes of any length.
We also show how to encode messages in cyclic codes.
An alternate way of describing cyclic codes is also explained, using what we call generating idempotents.
Finally, we explain the concept of zeroes of cyclic codes, a notion we'll need in the next chapter.

\paragraph{Chapter 4} In this chapter, we describe the family of BCH codes and the ``classic'' version of the Peterson-Gorenstein-Zierler algorithm for BCH codes.
We also take an opportunity to briefly introduce the family of RS codes, as we'll refer to them in later chapters.
To properly introduce BCH codes, we explain the BCH bound, a result that links the concept of zeroes of a cyclic code and the minimum distance of said code.
Then BCH codes are defined to take advantage of the BCH bound.
This means that it's possible to design BCH codes with any error correction capability, although their length will vary accordingly.
To end this chapter we take on the Peterson-Gorenstein-Zierler algorithm for BCH codes: we explain the decoding procedure and justify why it works.

\paragraph{Chapter 5} In this chapter, we move onto Ore Polynomial Rings.
Since we are working with finite fields with codes we'll limit our Ore Polynomial Rings study over them.
We introduce the main concepts as well as algorithms to calculate division from left or right and an extented Euclid algorithm.
We also state the fact that factorization of this kind of polynomials is not unique in the common sense, but there's a similar concept.

\paragraph{Chapter 6} In this chapter, we describe the family of Skew Cyclic Codes.
Throughout the chapter we set the basis for the introduction of Skew RS Codes at the end.
This is the family of codes that we will be using with the algorithm that is explained in the following chapter.

\paragraph{Chapter 7} Finally, in this chapter, we introduce the algorithm that is the main objective of this project: the Peterson-Gorenstein-Zierler algorithm for Skew Cyclic Codes.
As we did with the analogous algorithm for BCH codes we explain the decoding procedure as well as provide proof of why it works.

As part of this project we've developed various classes for Sage.
\begin{itemize}
  \item A decoder class for Sage's BCH codes that uses the Peterson-Gorenstein-Zierler algorithm described here.
  \item A skeleton class for Skew Cyclic Codes. That means we have not developed methods for this class but rather left a framework for other classes to be inherited by this one.
  \item A Skew RS Code class that implements the definition we study in this project, as well as a simple encoder class for them.
  \item Finally, a decoder class for the Skew RS Codes that we implemented that uses the Peterson-Gorenstein-Zierler algorithm for Skew Cyclic Codes that is the main goal of this project.
\end{itemize}

This classes allow us to work with these structures in Sage in a very natural form.
Throughout the project we will present some examples of the concepts we explain and we use Sage for that, either with the pre-existing classes or the classes we created.
We've also used some other helpful functions that we've described in annex \ref{annex:sage-gen-idemp}.

\paragraph{Keywords}
\begin{itemize*}[label=,itemsep=4em,itemjoin=\hspace{2em}]
  \item cyclic codes 
  \item skew polynomials
\end{itemize*}