\chapter{Fundamentos de teoría de códigos}

La teoría de códigos (...). Las definiciones y los resultados comentados en esta sección seguirán lo descrito en \parencite[1-48]{huffman_fundamentals_2003} y \parencite{podesta_introduccion_2006}.

\section{Códigos lineales}

Vamos a comenzar nuestro estudio con los códigos lineales, pues son los más sencillos de comprender. Consideremos el espacio vectorial de todas las \(n\)-tuplas sobre el cuerpo finito \(\mathbb F_q\), al que denotaremos en lo que sigue como \(\mathbb F_q^n\). A los elementos \((a_1, \dots, a_n)\) de \(\mathbb F_q^n\) los notaremos usualmente como \(a_1\!\cdots a_n\).

\begin{definition}
  Un \((n, M)\) \textit{código} \(\mathcal C\) sobre el cuerpo \(\mathbb F_q\) es un subconjunto de \(\mathbb F_q^n\) de tamaño \(M\). A los elementos de \(\mathcal C\) los llamaremos \textit{palabras codificadas} —o \textit{codewords} en inglés—.
\end{definition}

Es necesario añadir más estructura a los códigos para que sean de utilidad.

\begin{definition}
  Decimos que un código \(\mathcal C\) es un código \textit{lineal de longitud \(n\) y rango \(k\)} —abreviado como \([n, k]\) \textit{lineal}— si dicho código es un subespacio vectorial de \(\mathbb F_q^n\) de dimensión \(k\).
\end{definition}

Un código lineal \(\mathcal C\) tiene \(q^k\) palabras codificadas.

\begin{definition}
  Una \textit{matriz generadora} para un \([n, k]\) código \(\mathcal C\) es una matriz \(k \times n\) cuyas filas conforman una base de \(\mathcal C\).
\end{definition}

Veamos un ejemplo de matriz generadora. Consideremos la matriz \(G = \begin{psmallmatrix}
  1 & 1 & 0 \\ 0 & 1 & 1
\end{psmallmatrix} \in \mathcal M_{2 \times 3}(\mathbb F_2)\). Dicha matriz genera un \([3, 2]\) código binario, pues dado \((x_1, x_2)\), se tiene que \[(x_1, x_2) \begin{pmatrix}
  1 & 1 & 0 \\ 0 & 1 & 1
\end{pmatrix} = (x_1, x_1 + x_2, x_2),\] y por tanto este código codifica de la forma \[00 \to 000, \quad 01 \to 011,\quad 10 \to 110,\quad 11 \to 101.\]

\begin{definition}
  Para cada conjunto \(k\) de columnas independientes de una matriz generadora \(G\) el conjunto de coordenadas correspondiente se denomina \textit{conjunto de información} para un código \(\mathcal C\). Las \(r = n - k\) coordenadas restantes se llaman \textit{conjunto redundante}, y el número \(r\), la \textit{redundancia} de \(\mathcal C\).
\end{definition}

Si las primeras \(k\) coordenadas forman un conjunto de información el código tiene una única matriz generadora de la forma \([I_k \mid A]\), donde \(I_k\) es la matriz identidad \(k \times k\) y \(A\) es una matriz \(k \times r\). Esta matriz generadora se dice que está en \textit{forma estándar}.

%Como un código lineal es el subespacio de un espacio vectorial, es el núcleo de una transformación lineal. En particular, existe una matriz \(H\) de dimensiones \(r \times n\), llamada \textit{matriz de comprobación de paridad} para un \([n, k]\) código \(\mathcal C\) definida por \begin{equation}
%  \mathcal C = \left\{x \in \mathbb F_q^n : H \mathbf x^T = 0 %\right\}.
%\end{equation}

Como un código lineal \(\mathcal C\) es un subespacio de un espacio vectorial, podemos calcular el ortogonal a dicho subespacio, obteniendo lo que llamaremos el \textit{código dual} \(\mathcal C^{\perp}\).

\begin{definition}
  El \textit{código dual} \(\mathcal C^{\perp}\) de un código \(\mathcal C\) viene dado por \[\mathcal C^{\perp} = \left\{x \in \mathbb F_q^n : x \cdot c = 0 \quad \forall c \in \mathcal C\right\}.\]
\end{definition}

\begin{definition}
  Sea \(\mathcal C\) un \([n, k]\) código lineal. Una matriz \(H\) se dice que es \textit{matriz de paridad} si es una matriz generadora de \(\mathcal C^{\perp}\).
\end{definition}

\begin{proposition}
  Sea \(H\) la matriz de paridad de un \([n, k]\) código lineal \(\mathcal C\). Entonces, \[\mathcal C = \left\{x \in \mathbb F_q^n : xH^T = 0\right\} = \left\{x \in F_q^n : Hx^T = 0\right\}.\]
\end{proposition}

\begin{proof}
  Sea \(c \in \mathcal C\) una palabra codificada. Sabemos que la podemos expresar como \(c = uG\), donde \(u \in \mathbb F_q^k\) y \(G\) es la matriz generadora de \(\mathcal C\). Tenemos entonces que \(c\cramped{H^T} = uG\cramped{H^T}\) y como \(G\cramped{H^T} = 0\) —por ser H matriz generadora del subespacio ortogonal \(\mathcal C\)— se tiene que \[\mathcal C \subset S_H = \left\{x \in \mathbb F_q^n : Hx^T = 0\right\},\] que es el espacio solución de un sistema de \(n - k\) ecuaciones con \(n\) incógnitas y de rango \(n - k\). Como \(\dim(S_H) = n - (n - k) = k = \dim L\), concluimos que \[L = S_H = \left\{x \in \mathbb F_q^n : Hx^T = 0\right\}.\qedhere\]
\end{proof}

El resultado anterior, junto a la definición anterior, nos conducen al siguiente teorema. 

\begin{theorem}
  Si \(G = [I_k \mid A]\) es una matriz generadora para un \([n, k]\) código \(\mathcal C\) en forma estándar entonces \(H = [-A \mid I_{n-k}]\) es una matriz de paridad para \(\mathcal C\).
\end{theorem}

Un código se dice \textit{autoortogonal} cuando \(\mathcal C \subseteq \mathcal C^{\perp}\), y \textit{autodual} cuando \(\mathcal C = \mathcal C^{\perp}\).

\subsection{Distancias y pesos}

\begin{definition}
  La \textit{distancia de Hamming} \(\operatorname{d}(\symbf{x}, \symbf{y})\) entre dos vectores \(\symbf{x}, \symbf{y} \in \mathbb F_q^n\) se define como el número de coordenadas en las que difieren \(\symbf{x}\) e \(\symbf{y}\).
\end{definition}

\begin{theorem}
  La función de distancia \(\operatorname{d}(\symbf{x}, \symbf{y})\) verifica las siguientes propiedades.
  \begin{enumerate}
    \item No negatividad: \(\operatorname{d}(\symbf{x}, \symbf{y}) \geq 0\) para todo \(\symbf{x}, \symbf{y}\in \mathbb F_q^n\).
    \item \(\operatorname{d}(\symbf{x}, \symbf{y}) = 0\) si y solo si \(\symbf{x} = \symbf{y}\).
    \item Simetría: \(\operatorname{d}(\symbf{x}, \symbf{y}) = \operatorname{d}(\symbf{y}, \symbf{x})\) para todo \(\symbf{x}, \symbf{y}\in \mathbb F_q^n\).
    \item Desigualdad triangular: \(\operatorname{d}(\symbf{x}, \symbf{z}) \leq \operatorname{d}(\symbf{x}, \symbf{y}) + \operatorname{d}(\symbf{y}, \symbf{z})\) para todo elemento \(\symbf{x}, \symbf{y}, \symbf{z}\in \mathbb F_q^n\).
  \end{enumerate}
\end{theorem}

La \textit{distancia (mínima)} de un código \(\mathcal C\) es la menor distancia posible entre dos palabras codificadas distintas. 
Es importante a la hora de determinar la capacidad de corrección de errores del código \(\mathcal C\), pues como veremos más tarde, a mayor distancia mínima, mayor número de errores en el código se pueden corregir.

\begin{definition}
  El \textit{peso de Hamming} \(\operatorname{wt}(\symbf{x})\) de un vector \(\symbf{x}\) es el número de coordenadas distintas de cero de \(\symbf{x}\).
\end{definition}

\begin{theorem}
  Si \(\symbf{x}, \symbf{y} \in \mathbb F_q^n\), entonces \(\operatorname{d}(\symbf{x}, \symbf{y}) = \operatorname{wt}(\symbf{x} - \symbf{y})\).
  Si \(\mathcal C\) es un código lineal, la distancia mímina es igual al peso mínimo de las palabras codificadas de \(\mathcal C\) distintas de cero.
\end{theorem}

Como consecuencia de este teorema —para códigos lineales— la distancia mínima también se llama \textit{peso mínimo} del código.
Si el peso mínimo \(d\) de un \([n,k]\) código es conocida, nos referiremos a él como un \([n,k,d]\) código.

\begin{definition}
  Sea \(A_i(\mathcal C)\) —que abreviaremos \(A_i\)— el número de palabras codificadas de peso \(i\) en \(\mathcal C\).
  Para cada \(0 \leq i \leq n\), la lista \(A_i\) se denomina \textit{distribución de peso} o \textit{espectro de peso} de \(\mathcal C\).
\end{definition}

\begin{example}
  Sea \(\mathcal C\) el código binario con matriz generadora
  \[
    G = \begin{pmatrix}
      1 & 1 & 0 & 0 & 0 & 0\\
      0 & 0 & 1 & 1 & 0 & 0 \\
      0 & 0 & 0 & 0 & 1 & 1
    \end{pmatrix}.
  \]
  Dado \((x_1, x_2, x_3)\), se tiene que \[(x_1, x_2, x_3) \begin{pmatrix}
    1 & 1 & 0 & 0 & 0 & 0\\
      0 & 0 & 1 & 1 & 0 & 0 \\
      0 & 0 & 0 & 0 & 1 & 1
  \end{pmatrix} = (x_1, x_1, x_2, x_2, x_3, x_3),\] y por tanto este código codifica de la forma 
  \[
    000 \to 000000, \quad 
    001 \to 000011,\quad 
    010 \to 001100,\quad 
    011 \to 001111,
  \]
  \[
    100 \to 110000, \quad 
    101 \to 110011,\quad 
    110 \to 111100,\quad 
    111 \to 111111.
  \]
  Luego la distribución de peso de \(\mathcal C\) es \(A_0 = A_6 = 1\) y \(A_2 = A_4 = 3\).
  Usualmente solo se listan los \(A_i\) que son distintos de cero.
\end{example}

\begin{theorem}
  Sea \(\mathcal C\) un \([n,k,d]\) código sobre \(\mathbb F_q\).
  Entonces, \begin{enumerate}
    \item \(A_0(\mathcal C) + A_1(\mathcal C) + \cdots + A_n(\mathcal C) = q^k\).
    \item \(A_0(\mathcal C) = 1\) y \(A_1(\mathcal C) = A_2(\mathcal C) = \cdots = A_{d-1}(\mathcal C) = 0\).
  \end{enumerate}
\end{theorem}

% Theorem 1.4.13, Corollary 1.4.14 (Huffman-Pless), p.12-13

\begin{theorem}
  Sea \(\mathcal C\) un código lineal con matriz de paridad \(H\). Si \(\symbf{c} \in \mathcal C\), las columnas de \(H\) que se corresponden con coordenadas no nulas de \(\symbf{c}\) son linealmente independientes.
  Recíprocamente, si entre \(w\) columnas de \(H\) existe una relación de dependencia lineal con coeficientes no nulos, entonces hay una palabra codificada en \(\mathcal C\) de peso \(w\) cuyas coordenadas no nulas se corresponden con dichas columnas.
\end{theorem}

\begin{corollary}
  \label{cor:peso-minimo-columnas-dependientes}
  Un código lineal tiene peso mínimo \(d\) si y solo si su matriz de paridad tiene un conjunto de \(d\) columnas linealmente dependientes pero no tiene un conjunto de \(d-1\) columnas linealmente dependientes.
\end{corollary}

% TODO: teoremas sobre códigos que cumplen ciertas condiciones, no sé si merece Huffman 9-11

\section{Ejemplos de códigos}

\subsection{Códigos de Hamming}

Consideremos una matriz \(r \times (2^r - 1)\) cuyas columnas son los números \(1, 2, 3, \dots, 2^{r-1}\) escritos en binario. 
Dicha matriz es la matriz de paridad de un \([n=2^{r-1}, k=n-r]\) código binario.
A los códigos de esta forma los llamaremos códigos de Hamming de longitud \(n = 2^{r-1}\) y los denotamos por \(\mathcal H_r\) o \(\mathcal H_{2,r}\).

Como las columnas son distintas y no dula, la distancia es al menos \(3\) por el corolario \ref{cor:peso-minimo-columnas-dependientes}.
Además, como las columnas correspondientes a los números \(1, 2, 3\) son linealmente independientes, la distancia mínima es 3 por el mismo corolario.
Podemos decir por tanto que los códigos de Hamming \(\mathcal H_r\) son \([2^{r-1}, 2^{r-1-r}, 3]\) códigos binarios.

Podemos generalizar esta definición y definir los códigos de Hamming \(\mathcal H_{q,r}\) sobre un cuerpo finito arbitrario \(\mathbb F_q\). 
Para \(r \geq 2\) un código \(\mathcal H_{q,r}\) tiene matriz de paridad \(H_{q,r}\), cuyas columnas están compuestas por un vector no nulo por cada uno de los subespacios de dimensión \(1\) de \(\mathbb F_q^r\).
Hay \((q^r-1)/(q-1)\) subespacios de dimensión \(1\), por lo que \(\mathcal H_{q,r}\) tiene longitud \(n = (q^r-1)/(q-1)\), dimensión \(n-r\) y redundancia \(r\).
Como todas las columnas son independientes unas de otras, \(\mathcal H_{q,r}\) tiene peso mínimo al menos 3.
Si sumamos dos vectores no nulos de dos subespacios unidimensionales distintos obtenemos un vector no nulo de un tercer subespacio unidimensional, por lo que \(\mathcal H_{q,r}\) tiene peso mínimo 3. 
Cuando \(q = 2\), \(\mathcal H_{2,r}\) es el código \(\mathcal H_r\).

% TODO
% - por qué los códigos de Hamming son importantes
% - en qué se utilizan los códigos de Hamming

\section{Códigos cíclicos}

Un código lineal \(\mathcal C\) de longitud \(n\) sobre \(\mathbb F_q\) es \textit{cíclico} si para cada vector \(\mathbf c = c_0\dots c_{n-2}c_{n-1}\) en \(\mathcal C\), el vector \(c_{n-1}c_0\dots c_{n-2}\) --obtenido a partir de \(\mathbf c\) desplazando cíclicamente las coordenadas, llevando \(i \mapsto i +1 \bmod n\)-- también está en \(\mathcal C\).
Pensamos en la posición de las coordenadas de forma cíclica, pues al llegar a \(n -1\) se comienza de nuevo en \(0\).
Al hablar de <<coordenadas consecutivas>> siempre tendremos en cuenta esta ciclicidad.

% FIXME: revisar uso palabra "ciclicidad"

Cuando trabajemos con códigos cíclicos representaremos las palabras codificadas como polinomios.
Existe una biyección evidente entre el vector \(\mathbf c = c_0c_1\dots c_{n-1}\) en \(\mathbb F_q\) y los polinomios de la forma \(c(x) = c_0 + c_1x + \dots c_{n-1}x^{n-1}\) en \(\mathbb F_q[x]\) de grado al menos \(n-1\).
Obsérvese que dado un polinomio \(c(x)\) descrito como antes, el polinomio \(xc(x) = c_{n-1}x^n + c_0x + c_1x^2 + \dots + c_{n-2}x^{n-1}\) equivale a representar la palabra codificada \(\mathbf c\) desplazada una posición a la derecha, siempre que \(x^n\) fuese igual a \(1\).

Formalmente, el hecho de que un código \(\mathcal C\) sea invariante bajo un desplazamiento cíclico implica que si \(c(x)\) está en \(\mathcal C\), también ha de estar \(xc(x)\), siempre que multipliquemos módulo \(x^n -1\). 
Esto nos sugiere que el contexto para estudiar códigos cíclicos es el anillo cociente \(\mathcal R_n = \mathbb F_q[x]/(x^n - 1)\).

Por tanto, bajo la correspondencia vectores-polinomios que hemos descrito antes, los códigos cíclcos son ideales de \(\mathcal R_n\), y los ideales de \(\mathcal R_n\) son códigos cíclicos.
En consecuencia, el estudio de los códigos cíclicos en \(\mathbb F_q^n\) es equivalente al estudio de los ideales en \(\mathcal R_n\), que depende de la factorización de \(x^n-1\).

\subsection{Factorización de \(x^n -1\)}

\label{sec:factorizacion-xn-1}

Existen dos posibilidades: o bien \(x^n -1\) tiene factores irreducibles repetidos, o no.
Por la proposición * sabemos que \(x^n - 1\) no tiene factores repetidos si y solo si \(q\) y \(n\) son primos relativos, algo que supondremos cierto en lo que sigue.
% TODO: referenciar ejercicio 201, que aparecerá como proposición

Para factorizar \(x^n - 1\) sobre \(\mathbb F_q\) es útil considerar la extensión de cuerpos \(\mathbb F_{q^t}\) de \(\mathbb F_q\) que contenga todas sus raíces.
\(\mathbb F_{q^t}\) debe contener una enésima raíz primitiva de la unidad, que ocurre cuando \(n \mid (q^t - 1)\) por el teorema *.
% TODO: referenciar teorema (Th 3.3.3, ECC)
Definimos el \textit{orden} \(\operatorname{ord}_n(q)\) de \(q\) módulo \(n\) como el menor entero positivo \(a\) tal que \(q^{a} \equiv 1 \bmod n\).
Si \(t = \operatorname{ord}_n(q)\) entonces \(\mathbb F_{q^t}\) contiene una enésima raíz primitiva de la unidad \(\alpha\) pero no hay una extensión de cuerpos más pequeña de \(\mathbb F_q\) que la contenga.
Como todos los \(\alpha^{i}\) son distintos dos a dos para \(0 \leq i < n\) y \((\alpha^{i})^n = 1\), entonces \(\mathbb F_{q^t}\) contiene todas las raíces de \(x^n - 1\).
Por tanto, \(\mathbb F_{q^t}\) es lo que se conoce como \textit{cuerpo de descomposición} de \(x^n - 1\) sobre \(\mathbb F_q\).

Los factores irreducibles de \(x^n - 1\) sobre \(\mathbb F_q\) deben ser el producto de los distintos polinomios minimales de las enésimas raíces de la unidad en \(\mathbb F_{q^t}\).
Supongamos que \(\gamma\) es un elemento primitivo de \(\mathbb F_{q^t}\).
Entonces \(\alpha = \gamma^d\) es una enésima raíz primitiva de la unidad, donde \(d = (q^t - 1)/n\).
Las raíces del polinomio \(M_{a^s}(x)\) son \(\{\gamma^{ds}, \gamma^{dsq}, \gamma^{dsq^2}, \dots, \gamma^{dsq^{r-1}}\} = \{\alpha^s, \alpha^{sq}, \alpha^{sq^2}, \dots, \alpha^{sq^{r-1}}\}\), donde \(r\) es el menor entero positivo tal que \(dsq^r \equiv ds \bmod q^t - 1\) por el teorema *.
% TODO: referenciar Theorem 3.7.6
Pero \(dsq^r \equiv ds \bmod q^t - 1\) si y solo si \(sq^r \equiv s \bmod n\).

Todo esto nos lleva a extender la definición de clases \(q\)-ciclotómicas que hemos introducido en la sección *.
Sea \(s\) un entero tal que \(0 \leq s < n\).
La \textit{clase \(q\)-ciclotómica de \(s\) módulo \(n\)} es el conjunto
\[
  C_s = \{s, sq, \dots, sq^{r-1}\} \bmod n, 
\]
donde \(r\) es el menor entero positivo tal que \(sq^r \equiv s \bmod n\).
Se deduce entonces que \(C_s\) es la órbita de la permutación \(i \mapsto iq \bmod n\) que contiene a \(s\).
Las distintas clases \(q\)-ciclotómicas módulo \(n\) dividen el conjunto de enteros \(\{0, 1, 2, \dots, n - 1\}\).
En la sección * estudiamos el caso particular en el que \(n = q^t - 1\).
Obsérvese que \(\operatorname{ord}_n(q)\) es el tamaño de la clase \(q\)-ciclotómica \(C_1\) módulo \(n\).

\begin{theorem}
  Sea \(n\) un entero positivo primo relativo con \(q\).
  Sea \(t = \operatorname{ord}_n(q)\).
  Sea \(\alpha\) una raíz enésima primitiva de la unidad en \(\mathbb F_{q^t}\).
  Se verifican las siguientes afirmaciones.
  \begin{enumerate}
    \item Para cada entero \(s\) tal que \(0 \leq s < n\) el polinomio minimal de \(\alpha^s\) sobre \(\mathbb F_q\) es
    \[
      M_{\alpha^s}(x) = \prod_{i \in C_s}(x - \alpha^i),
    \]
    donde \(C_s\) es la clase \(q\)-ciclotómica de \(s\) módulo \(n\).
    \item Los conjugados de \(\alpha^s\) son los elementos \(\alpha^i\) con \(i \in C_s\).
    \item Se tiene que
    \[
      x^n - 1 = \prod_s M_{\alpha^s}(x)
    \]
    es la factorización de \(x^n - 1\) en factores irreducibles sobre \(\mathbb F_q\), donde \(s\) varía en un conjunto de representantes de las clases \(q\)-ciclotómicas módulo \(n\).
  \end{enumerate}
\end{theorem}

\begin{proof}
  % TODO (en el libro no viene)
\end{proof}

\begin{theorem}
  El tamaño de cada clase \(q\)-ciclotómica es un divisor de \(\operatorname{ord}_n(q)\).
  Además, el tamaño de \(C_1\) es \(\operatorname{ord}_n(q)\).
\end{theorem}

\subsection{.}

Vamos a ver que hay una correspondencia biyectiva entre los códigos cíclicos en \(\mathcal R_n\) y los polinomios mónicos divisores de \(x^n-1\).

\begin{theorem}
  \label{th:corr-cod-div}
  Sea \(\mathcal C\) un ideal de \(\mathcal R_n\), es decir, un código cíclico de longitud \(n\). Entonces:
  \begin{enumerate}
    \item Existe un único polinomio mónico \(g(x)\) de grado mínimo en \(\mathcal C\).\label{thi:corr-codc-div:monico-minimo}
    \item El polinomio descrito en (\ref{thi:corr-codc-div:monico-minimo}) genera \(\mathcal C\), es decir, \(\mathcal C = \langle g(x)\rangle\).
    \item El polinomio descrito en (\ref{thi:corr-codc-div:monico-minimo}) verifica que \(g(x) \mid x^n -1\).\label{thi:corr-codc-div:div-xn-1}
  \end{enumerate}
  Sea \(k = n - \operatorname{gr} g(x)\) y sea \(g(x) = \sum_{i_0}^{n-k}g_ix^{i}\), donde \(g_{n-k} = 1\). Entonces:
  \begin{enumerate}[resume]
    %\item La dimensión de \(\mathcal C\) es \(k\) y \(\{g(x), xg(x), \dots, x^{k-1}g(x)\}\) es una base de \(\mathcal C\).
    %\item Cada elemento de \(\mathcal C\) se puede expresar como producto de \(g(x)\) por un polinomio \(f(x)\), donde \(f(x) = 0\) o bien \(\operatorname{gr} f(x) < k\).
    \item \label{thi:corr-codc-div:dim-ideal} Se verifica que \[
      \mathcal C = \langle g(x) \rangle = \{f(x)g(x) : \operatorname{gr} f(x) < k\}.
    \]
    \item El conjunto \(\{g(x), xg(x), \dots, x^{k-1}g(x)\}\) es una base de \(\mathcal C\) y \(\mathcal C\) tiene dimensión \(k\).
    \item La matriz \(G\) dada por \begin{align*}
      G &= \begin{bmatrix}
        g_0 & g_1 & g_2 & \dots & \dots & g_{n-k} & 0 & 0 & \dots & 0 \\
        0 & g_0 & g_1 & g_2 & \dots & \dots & g_{n-k} & 0 & \dots & 0 \\
        0 & 0 & g_0 & g_1 & g_2 & \dots & \dots & g_r & \ddots & \vdots \\
        \vdots & \vdots & \ddots & \ddots & \ddots & \ddots & & & \ddots & 0\\
        0 & 0 & \dots & 0 & g_0 & g_1 & g_2 & \dots & \dots & g_{n-k} 
      \end{bmatrix},
      % \\
      %   &\iff \begin{bmatrix}
      %     g(x) & & & \\
      %      & xg(x) & & \\
      %      & & \dots & \\
      %      & & & x^{k-1}g(x)
      %   \end{bmatrix}
    \end{align*}
    donde cada fila es un desplazamiento cíclico de la fila previa, es una matriz generadora de \(\mathcal C\).
    \item \label{thi:pol-generador-prod-minimal} Si \(\alpha\) es una enésima raíz primitiva de la unidad en alguna extensión de cuerpos de \(\mathbb F_q\) entonces \[
      g(x) = \prod_s M_{\alpha^s}(x),
    \] siendo dicho producto sobre un subconjunto de representantes de las clases \(q\)-ciclotómicas módulo \(n\).
  \end{enumerate}
\end{theorem}

\begin{proof}
  Veamos la demostración apartado por apartado.
  \begin{enumerate}
    \item Supongamos que \(\mathcal C\) contiene dos polinomios mónicos distintos, \(g_1(x)\) y \(g_2(x)\), ambos de grado mínimo \(r\). 
    Entonces, \(g_1(x) - g_2(x)\) es un polinomio no nulo de grado menor que \(r\), lo que es absurdo. 
    Existe por tanto un único polinomio de grado mínimo \(r\) en \(\mathcal C\), como queríamos.
    \item Como \(g(x) \in \mathcal C\) y \(\mathcal C\) es un ideal, tenemos que \(\langle g(x)\rangle \subset \mathcal C\). 
    Por otra parte, dado \(p(x) \in \mathcal C\) el algoritmo de división nos da elementos \(q(x), r(x)\) tales que \(p(x) = q(x)g(x) + r(x)\), de forma que o bien \(r(x) = 0\) o bien \(\operatorname{gr} r(x) < \operatorname{gr} g(x)\). 
    Como podemos expresar \(r(x)\) de la forma \(r(x) = p(x) - q(x)g(x) \in \mathcal C\) y tiene grado menor que \(\operatorname{gr} g(x)\), al ser este último de grado mínimo necesariamente ha de darse que \(r(x) = 0\).
    Por tanto, \(p(x) = q(x)g(x) \in \langle g(x) \rangle\) y \(\mathcal C \subset \langle g(x) \rangle\).
    En consecuencia, \(\langle g(x) \rangle = \mathcal C\).
    \item Por el algoritmo de división, al dividir \(x^n - 1\) por \(g(x)\) tenemos que \(x^n - 1 = q(x)g(x) + r(x)\). De nuevo, o bien \(r(x) = 0\) o bien \(\operatorname{gr} r(x) < \operatorname{gr} g(x)\).
    Como en \(\mathcal R_n\) se tiene que \(x^n - 1 = 0 \in \mathcal C\), necesariamente \(r(x) \in \mathcal C\).
    Esto supone una contradicción, a menos que \(r(x) = 0\).
    % FIXME: por qué supone una contradicción??? mirar 24-2-20 en el cuaderno
    En consecuencia, \(g(x) \mid x^n - 1\).
    \item El ideal generado por \(g(x)\) es \(\langle g(x) \rangle = \{f(x)g(x) : f(x) \in \mathcal R_n\}\).
    Queremos ver que podemos restringir los polinomios \(f(x)\) a aquellos que tengan grado menor que \(k\).
    Por (\ref{thi:corr-codc-div:div-xn-1}) sabemos que \(x^n-1 = h(x)g(x)\) para algún polinomio \(h(x)\) que tenga grado \(k = n - \operatorname{gr} g(x)\).
    Dividimos entonces \(f(x)\) por este polinomio \(h(x)\) y por el algoritmo de división obtenemos \(f(x) = q(x)h(x) + r(x)\), donde \(\operatorname{gr} r(x) < \operatorname{gr} h(x) = k\).
    Entonces, tenemos \begin{align*}
      f(x)g(x) &= q(x)h(x)g(x) + r(x)g(x)\\
               &= q(x)(x^n - 1) + r(x)g(x),
    \end{align*}
    luego \(f(x)g(x) = r(x)g(x)\), y puesto que antes ya hemos visto que \(\operatorname{gr} r(x) < k\), hemos obtenido lo que buscábamos.
    \item A partir de (\ref{thi:corr-codc-div:dim-ideal}) tenemos que el conjunto \[\{g(x), xg(x), \dots, x^{k-1}g(x)\}\] genera \(\mathcal C\), y como es linealmente independiente, forma una base de \(\mathcal C\).
    Esto demuestra también que la dimensión de \(\mathcal C\) es \(k\).
    \item La matriz \(G\) es matriz generadora de \(\mathcal C\) pues \[\{g(x), xg(x), \dots, x^{k-1}g(x)\}\] es una base de \(\mathcal C\).
    \item TODO. % TODO: apartado 7, tiene que ver con la factorización de x^n - 1 que todavía no he comentado
  \end{enumerate}
\end{proof}

Este teorema nos muestra que existe un polinomio mónico \(g(x)\) que divide a \(x^n - 1\) y genera \(\mathcal C\).
Vamos a ver a continuación que dicho polinomio es único.

\begin{corollary}
  \label{cor:pol-gen-unico}
  Sea \(\mathcal C\) un código cíclico en \(\mathcal R_n\) distinto de cero.
  Son equivalentes:
  \begin{enumerate}
    \item El polinomio \(g(x)\) es el polinomio mónico de menor grado en \(\mathcal C\).
    \item Podemos expresar \(\mathcal C\) como \(\mathcal C = \langle g(x)\rangle\), \(g(x)\) es mónico y \(g(x) \mid (x^n -1)\).
  \end{enumerate}
\end{corollary}

\begin{proof}
  Que (1) implica (2) ya lo hemos probado en el teorema \ref{th:corr-cod-div}. 
  Veamos que partiendo de (2) obtenemos (1). 
  Sea \(g_1(x)\) el polinomio mónico de menor grado en \(\mathcal C\).
  Por el teorema \ref{th:corr-cod-div}, \(g_1(x) \mid g(x)\) en \(\mathbb F_q[x]\) y \(\mathcal C = \langle g_1(x)\rangle\).
  Como \(g_1(x) \in \mathcal C = \langle g(x) \rangle\), podemos expresarlo como \(g_1(x) = g(x)a(x) \bmod x^n - 1\), luego tenemos que \(g_1(x) = g(x)a(x) + (x^n - 1)b(x)\) en \(\mathbb F_q[x]\).
  Por otro lado, como \(g(x) \mid (x^n - 1)\), tenemos que \(g(x) \mid g(x)a(x) + (x^n-1)b(x)\), o lo que es lo mismo, que \(g(x) \mid g_1(x)\). 
  En consecuencia, como \(g_1(x)\) y \(g(x)\) son ambos mónicos y dividen el uno al otro en \(\mathbb F_q[x]\), son necesariamente iguales.
\end{proof}

A este polinomio lo llamamos \textit{polinomio generador} del código cíclico \(\mathcal C\).
Por el corolario anterior, este polinomio es tanto el polinomio mónico en \(\mathcal C\) de grado mínimo como el polinomio mónico que divide a \(x^n - 1\) y genera a \(\mathcal C\).
Existe por tanto una correspondencia biunívoca entre los códigos cíclicos distintos de cero y los divisores de \(x^n - 1\) distintos de él mismo.
Para extender dicha correspondencia entre todos los códigos cíclicos en \(\mathcal R_n\) y todos los divisores mónicos de \(x^n - 1\) definimos como polinomio generador del código cíclico \(\{\mathbf 0\}\) el polinomio \(x^n - 1\). 
Esta correspondencia biyectiva nos conduce al siguiente corolario.

\begin{corollary}
  El número de códigos cíclicos en \(\mathcal R_n\) es \(2^m\), donde \(m\) es el número de clases \(q\)-ciclotómicas módulo \(n\).
  Es más, las dimensiones de los códigos cíclicos en \(\mathcal R_n\) son todas sumas de tamaños de las clases \(q\)-ciclotómicas módulo \(n\).
\end{corollary}

\begin{proof}
  % TODO: demostrar? en el libro no viene demostrado y tampoco entiendo muy bien la segunda afirmación
\end{proof}

% TODO: ejemplo? ejemplo 4.2.4 del libro

El siguiente resultado nos muestra la relación entre dos polinomios generadores cuando un código es subcódigo de otro.

\begin{corollary}
  Sean \(\mathcal C_1\) y \(\mathcal C_2\) códigos cíclicos sobre \(\mathbb F_q\) con polinomios generadores \(g_1(x)\) y \(g_2(x)\), respectivamente.
  Entonces, \(\mathcal C_1 \subset \mathcal C_2 \) si y solo si \(g_2(x) \mid g_1(x)\).
\end{corollary}

% TODO: resultados sobre duales de códigos cíclicos (4.2.6, 4.2.7)

\subsection{Codificación y decodificación de códigos cíclicos}

Los códigos cíclicos son más sencillos de decodificar que otros tipos de códigos debido a su estructura adicional.
Vamos a ver a continuación tres tipos de codificación de códigos cíclicos.
Consideraremos un código cíclico \(\mathcal C\) de longitud \(n\) sobre \(\mathbb F_q\) con polinomio generador \(g(x)\) de grado \(n - k\), por lo que \(\mathcal C\) tiene dimensión \(k\).

\paragraph{Codificación no-sistemática}

Esta forma de codificación está basada en la técnica natural de codificación que describimos en la sección (
  %TODO: referencia
).
Sea \(G\) la matriz generadora obtenida a partir de los desplazamientos de \(g(x)\) descrita en el teorema \ref{th:corr-cod-div}.
Dado el mensaje \(\mathbf m \in \mathbb F_q^k\), lo codificamos como la palabra codificada \(\mathbf c = \mathbf mG\).
De igual forma, si \(m(x)\) y \(c(x)\) son los polinomios en \(\mathbb F_q[x]\) asociados a \(\mathbf{m}\) y \(\mathbf c\), entonces \(c(x) = m(x)g(x)\).

\paragraph{Codificación sistemática}

El polinomio \(m(x)\) asociado a un mensaje \(\mathbf m\) tendrá como mucho grado \(k -1\).
Por tanto, el polinomio \(n^{n-k}m(x)\) tendrá como mucho grado \(n - 1\) y sus primeros \( n - k\) coeficientes son nulos.
Por tanto, el mensaje está contenido en los coeficientes de \(x^{n-k}, x^{n-k+1}, \dots, x^{n-1}\).
Por el algoritmo de división tenemos que
\[x^{n-k}m(x) = g(x)a(x) + r(x), \qquad \text{donde } \operatorname{gr} r(x) < n - k \text{ o } r(x) = 0.\]
Sea \(c(x) = x^{n-k}m(x) - r(x)\).
Como \(c(x)\) es múltiplo de \(g(x)\), \(c(x) \in \mathcal C\).
El polinomio \(c(x)\) difiere de \(x^{n-k}m(x)\) en los coeficientes de \(1, x, \dots, x^{n-k-1}\) ya que \(\operatorname{gr} r(x) < n-k\).
Por tanto, \(c(x)\) contiene el mensaje \(\mathbf m\) en los coeficientes de los términos de grado al menos \(n - k\).

\paragraph{Codificación sistemática usando el código dual}

Aquí vamos

\begin{example}
  Sea \(\mathcal C\) un código cíclico de longitud 15 con polinomio generador \(g(x) = (1 + x + x^4)(1 + x + x^2 + x^3 + x^4)\). Vamos a ver su codificación con los tres métodos descritos.
\end{example}

\section{Idempotentes, multiplicadores y ceros de un código cíclico}

% TODO: something something sobre que R_n es semisimple y Wedderburn Structure Theorems

Cada código cíclico en \(\mathcal R_n\) contiene un único idempotente que genera el ideal.
Este elemento se denomina \textit{idempotente generador} del código cíclico.
En el siguiente teorema probaremos este hecho y mostraremos además un método para determinar el idempotente generador de un código cíclico.

\begin{theorem}
  \label{th:idempotente-unico-unidad}
  Sea \(\mathcal C\) un código cíclico en \(\mathcal R_n\). Entonces:
  \begin{enumerate}
    \item Existe un único idempotente \(e(x) \in \mathcal C\) tal que \(\mathcal C = \langle e(x)\rangle\).
    \item Si \(e(x)\) es un idempotente no nulo en \(\mathcal C\), entonces \(\mathcal C = \langle e(x)\rangle\) si y solo si \(e(x)\) es la unidad de \(\mathcal C\).
  \end{enumerate}
\end{theorem}

\begin{proof}
  Si \(\mathcal C\) es el código cero, entonces el idempotente es el cero, con lo que (1) está claro y (2) no se aplica a este caso. 
  Veamos entonces la demostración por apartados suponiendo que \(\mathcal C\) es distinto de cero.
  \begin{enumerate}
    \item Supongamos primero que \(e(x)\) es una unidad en \(\mathcal C\). 
    Entonces, \(\langle e(x)\rangle \subset \mathcal C\), ya que \(\mathcal C\) es un ideal.
    Si \(c(x) \in \mathcal C\), entonces \(c(x)e(x) = c(x)\) en \(\mathcal C\).
    En consecuencia, \(\langle e(x)\rangle = \mathcal C\).
    Por otro lado, supongamos que \(e(x)\) es un idempotente distinto de cero y tal que \(\mathcal C = \langle e(x)\rangle\).
    Entonces, cada elemento \(c(x)\) lo podemos escribir como \(c(x) = f(x)e(x)\).
    Pero se tiene que \(c(x)e(x) = f(x)(e(x))^2 = f(x)e(x) = c(x)\), luego \(e(x)\) es la unidad de \(\mathcal C\).
    \item Tenemos que probar la existencia y la unicidad.
    Comenzamos con la existencia.
    Sea \(g(x)\) el polinomio generador dde \(\mathcal C\).
    Entonces, sabemos que \(g(x) \mid (x^n - 1)\) por el teorema \ref{th:corr-cod-div}.
    Tomemos \(h(x) = (x^n - 1)/g(x)\).
    Sabemos que \(\operatorname{mcd}(g(x), h(x)) = 1\) en \(\mathbb F_q[x]\), ya que \(x^n - 1\) tiene todas sus raíces distintas.
    En consecuencia, el algoritmo de Euclides %TODO: está explicado?
    nos proporciona los polinomios \(a(x),b(x) \in \mathbb F_q[x]\) tales que \(a(x)g(x) + b(x)h(x) = 1\).
    Llamemos \(e(x) \equiv a(x)g(x) \bmod x^n - 1\), que será el representante de dicha clase de equivalencia en \(\mathcal R_n\).
    Entonces, en \(\mathcal R_n\),
    \begin{align*}
      e(x)^2 &\equiv (a(x)g(x))(1 - b(x)h(x)) \bmod x^n - 1\\
        &\equiv a(x)g(x) - a(x)g(x)b(x)h(x) \bmod x^n - 1\\
        &\equiv a(x)g(x) - a(x)b(x)(x^n - 1) \bmod x^n - 1\\
        &\equiv a(x)g(x) \bmod x^n - 1\\
        &\equiv e(x) \bmod x^n - 1.
    \end{align*}
    Por tanto, este elemento \(e(x)\) es idempotente.
    Veamos ahora que si \(c(x) \in \mathcal C\), entonces \(c(x) = f(x)g(x)\), luego
    \begin{align*}
      c(x)e(x) &= f(x)g(x)(1 - b(x)h(x))\\
        &\equiv f(x)g(x) \bmod x^n - 1\\
        &\equiv c(x) \bmod x^n - 1,
    \end{align*}
    por lo que \(e(x)\) es la unidad en \(\mathcal C\).
    En consecuencia, podemos deducir la existencia a partir de (2).
    Veamos ahora la unicidad. Por (2), si tenemos dos elementos idempotentes \(e_1(x)\) y \(e_2(x)\) que generan \(\mathcal C\), ambos han de ser unidades, y en consecuencia se tiene que \(e_1(x) = e_1(x)e_2(x) = e_2(x)\), con lo que podemos deducir la unicidad.
  \end{enumerate}
\end{proof}

Deducimos por tanto que un método para encontrar el idempotente generador \(e(x)\) de un código cíclico \(\mathcal C\) a partir del polinomio generador \(g(x)\) es resolver la ecuación \[1 = a(x)g(x) + b(x)h(x)\] para \(a(x)\) utilizando el algoritmo de Euclides, donde \(h(x) = (x^n - 1)/g(x)\).
Entonces, reduciendo \(a(x)g(x)\) módulo \(x^n - 1\) obtenemos el idempotente \(e(x)\) que buscamos.
De hecho, el siguiente teorema nos muestra además que podemos obtener \(g(x)\) a partir de \(e(x)\). 

\begin{theorem}
  Sea \(\mathcal C\) un código cíclico sobre \(\mathbb F_q\) con idempotente generador \(e(x)\).
  Entonces, el polinomio generador de \(\mathcal C\) es \(g(x) = \operatorname{mcd}(e(x), x^n - 1)\), calculado en \(\mathbb F_q[x]\). 
\end{theorem}

\begin{proof}
  Sea \(d(x) = \operatorname{mcd}(e(x), x^n - 1)\) en \(\mathbb F_q[x]\) y sea \(g(x)\) el polinomio generador de \(\mathcal C\).
  Como \(d(x) \mid e(x)\), podemos expresarlo como \(e(x) = d(x)k(x)\) para algún \(k(x) \in \mathbb F_q[x]\).
  Por tanto cada elemento de \(\mathcal C = \langle e(x) \rangle\) es también múltiplo de \(d(x)\), por lo que \(\mathcal C \subset \langle d(x) \rangle\).
  Por el teorema \ref{th:corr-cod-div} tenemos que en \(\mathbb F_q[x]\), \(g(x) \mid (x^n -1)\) y que \(g(x) \mid e(x)\), ya que \(e(x) \in \mathcal C\).
  Luego, por la proposición (TODO: proposición, ejercicio 158) tenemos que \(g(x) \mid d(x)\) y en consecuencia \(d(x) \in \mathcal C\).
  Por tanto, \(\langle d(x) \rangle \subseteq \mathcal C\) y deducimos entonces que \(\mathcal C = \langle d(x) \rangle\).
  Como \(d(x)\) es divisor mónico de \(x^n - 1\) y genera a \(\mathcal C\), necesariamente \(d(x) = g(x)\) por el corolario \ref{cor:peso-minimo-columnas-dependientes}. 
\end{proof}

% MAYBE: ejemplos de códigos cíclicos 4.3.4, 4.3.5??

El siguiente teorema nos muestra --igual que para el polinomio generador-- que el idempotente generador y sus primeros \(k - 1\) desplazamientos cíclicos forman una base de un código cíclico.

\begin{theorem}
  Sea \(\mathcal C\) un \([n, k]\) código cíclico con idempotente generador \(e(x) = \sum_{i=0}^{n-1}e_ix^i\).
  Entonces, la matriz \(k \times n\)
  \[
    \begin{pmatrix*}
      e_0 & e_1 & e_2 & \dots & e_{n-2} & e_{n-1} \\
      e_{n-1} & e_0 & e_1 & \dots & e_{n-3} & e_{n-2} \\
       & & & \vdots & & \\
      e_{n-k+1} & e_{n-k+2} & e_{n-k+3} & \dots & e_{n-k-1} & e_{n-k}
    \end{pmatrix*}
  \] es una matriz generadora de \(\mathcal C\).
\end{theorem}

\begin{proof}
  Probar este resultado equivale a probar que el conjunto \(\{e(x), xe(x), \dots, x^{k-1}e(x)\}\) es una base de \(\mathcal C\).
  Entonces, solo hay que probar que si \(a(x) \in \mathbb F_q[x]\) tiene grado menor que \(k\), tal que \(a(x)e(x) = 0\), se tiene que \(a(x) = 0\).
  Sea \(g(x)\) el polinomio generador de \(\mathcal C\).
  Si \(a(x)e(x) = 0\), entonces \(0 = a(x)e(x)g(x) = a(x)g(x)\), tal que \(e(x)\) es la unidad de \(\mathcal C\) según el teorema \ref{th:idempotente-unico-unidad}, y por tanto, si \(a(x)\) no es cero estaríamos contradiciendo el teorema \ref{th:corr-cod-div}.
\end{proof}

% MAYBE: sumas e intersecciones de códigos cíclicos

Estamos ya en disposición de describir un conjunto especial de idempotentes, denominados \textit{idempotentes primitivos}.
Estos elementos, una vez conocidos, nos permitirán obtener todos los idempotentes en \(\mathcal R_n\), y en consecuencia, todos los códigos cíclicos.

Sea \(x^n - 1 = f_1(x)\cdots f_s(x)\), donde cada polinomio \(f_i(x)\) es irreducible sobre \(\mathbb F_q\) para \(1 \leq i \leq s\).
Todos los \(f_i(x)\) son distintos, pues \(x^n - 1\) tiene raíces distintas.
Sea \(\widehat{f_i}(x) = (x^n - 1)/f_i(x)\).
En el teorema * veremos que los ideales \(\langle \widehat{f_i}(x)\rangle\) de \(\mathcal R_n\) son los ideales minimales de \(\mathcal R_n\).
% FIXME: ideales minimales, definir
Al idempotente generador de \(\langle \widehat{f_i}(x)\rangle\) lo denotaremos por \(\widehat{e_i}(x)\).
Los elementos idempotentes \(\widehat{e_1}(x), \dots, \widehat{e_s}(x)\) se denominan \textit{primitivos idempotentes} de \(\mathcal R_n\).

\begin{theorem}
  En \(\mathcal R_n\) se verifican las siguientes afirmaciones.
  \begin{enumerate}
    \item Los ideales \(\langle \widehat{f_i}(x)\rangle\) para cada \(1 \leq i \leq s\) son todos los ideales minimales de \(\mathcal R_n\).
    \item \(\mathcal R_n\) es el espacio vectorial suma directa de todos los \(\langle \widehat{f_i}(x)\rangle\) para \(1 \leq i \leq s\).
    \item Si \(i \neq j\) entonces \(\widehat{e_i}(x)\widehat{e_j}(x) = 0\) en \(\mathcal R_n\).
    \item La suma \(\sum_{i=1}^s \widehat{e_i}(x) = 1\) en \(\mathcal R_n\).
    \item Los únicos idempotentes en \(\langle \widehat{f_i}(x)\rangle\) son \(0\) y \(\widehat{e_i}(x)\).
    \item Si \(e(x)\) es un idempotente no nulo en \(\mathcal R_n\), entonces existe un subconjunto \(T\) de \(\{1, 2, \dots, s\}\) tal que \(e(x) = \sum_{i \in T}\widehat{e_i}(x)\) y \(\langle e(x) \rangle = \sum_{i \in T}\langle \widehat{f_i}(x)\rangle\).
  \end{enumerate}
\end{theorem}

\begin{proof}
  
\end{proof}

El teorema * nos muestra que los ideales minimales del teorema * son extensiones de cuerpos de \(\mathbb F_q\).

\begin{theorem}
  Sea \(\mathcal M\) un ideal minimal de \(\mathcal R_n\).
  Entonces \(\mathcal M\) es una extensión de cuerpos de \(\mathbb F_q\).
\end{theorem}

\begin{proof}
  
\end{proof}

A continuación vamos a describir una permutación que lleva idempotentes de \(\mathcal R_n\) en idempotentes de \(\mathcal R_n\).
Sra \(a\) un entero tal que \(\operatorname{mcd}(a, n) = 1\).
La función \(\mu_a\) definida sobre \(\{0, 1, \dots, n -1\}\) por \(i\mu_a \equiv ia \bmod n\) es una permutación de las posiciones de coordenadas \(\{0, 1, \dots, n - 1\}\) de un código cíclico de longitud \(n\) y se denomina \textit{multiplicador}.
Dado que los códigos cíclicos de longitud \(n\) se representan como ideales de \(\mathcal R_n\), para \(a > 0\) es conveniente interpretar que \(\mu_a\) actúa sobre \(\mathcal R_n\) como
\begin{equation}
  \label{eq:multiplier-rn}
  f(x)\mu_a \equiv f(x^a) \bmod x^n - 1.
\end{equation}

Esta ecuación es consistente con la definición original de \(\mu_a\) pues \(x^i\mu_a = x^{ia} = x^{ia + jn}\) en \(\mathcal R_n\) para un entero \(j\) tal que \(0 \leq ia + jn\), pues \(x^n = 1\) en \(\mathcal R_n\).
En otras palabras, \(x^i\mu_a = x^{ia \bmod n}\).
Si \(a < 0\) podemos dar significado a \(f(x^a)\) en \(\mathcal R_n\) definiendo \(x^{i}\mu_a = x^{ia \bmod n}\), donde \(0 \leq ia \bmod n < n\).
Con esta interpretación la ecuación \ref{eq:multiplier-rn} es consistente con la definición original de \(\mu_a\) cuando \(a < 0\).

% TODO: Más sobre multiplicadores (4.3)

% TODO: Ceros de un código cíclico (4.4)

Como vimos en la sección \ref{sec:factorizacion-xn-1}, si \(t = \operatorname{ord}_n(q)\) entonces \(\mathbb F_{q^t}\) es un cuerpo de descomposición de \(x^n - 1\).
Por tanto, \(\mathbb F_{q^t}\) contiene una enésima raíz primitiva de la unidad \(\alpha\), y \(x^n - 1 = \prod_{i=0}^{n-1}(x - \alpha^{i})\) es la factorización de \(x^n - 1\) sobre \(\mathbb F_{q^t}\).
De hecho, \(x^n - 1 = \prod_s M_{\alpha^s}(x)\) es la factorización de \(x^n - 1\) en factores irreducibles sobre \(\mathbb F_q\), donde \(s\) varía en un conjunto de representantes de las clases \(q\)-ciclotómicas módulo \(n\).

Sea \(\mathcal C\) un código cíclico en \(\mathcal R_n\) con polinomio generador \(g(x)\).
Por los teoremas * y \ref{th:corr-cod-div}(\ref{thi:pol-generador-prod-minimal}), \(g(x) = \prod_{s}M_{\alpha^s}(x) = \prod_s\prod_{i \in C_s}(x - \alpha^{i})\), donde \(s\) de nuevo varía en un conjunto \(C_s\) de representantes de las clases \(q\)-ciclotómicas módulo \(n\).
Sea \(T = \cup_s C_s\) la unión de estas clases \(q\)-ciclotómicas.
Las raíces de la unidad \(\mathcal Z = \{\alpha^{i} \mid i \in T\}\) se denominan los \textit{ceros} del código cíclico \(\mathcal C\) y los elementos \(\{\alpha^{i} \mid i \notin T\}\), los \textit{elementos no nulos} de \(\mathcal C\).
El conjunto \(T\) se denomina \textit{conjunto característico} de \(\mathcal C\).
Se deduce del teorema \ref{th:corr-cod-div} que \(c(x)\) pertenece a \(\mathcal C\) si y solo si \(c(\alpha^{i}) = 0\) para cada \(i \in T\).
Es importante observar que \(T\), y por ello tanto el conjunto de ceros como el de elementos distintos de cero, determinan por completo el polinomio generador \(g(x)\).
Del teorema \ref{th:corr-cod-div} concluimos que la dimensión de \(\mathcal C\) es \(n - |T|\), pues \(|T|\) es el grado de \(g(x)\).

% MAYBE: ejemplo de esto??? Ejemplo 4.4.1

\section{Códigos BCH}

% 4.5 Mininum distance of cyclic codes (intro cota BCH)

Para cualquier tipo de código es importante determinar la distancia mínima con el fin de determinar su capacidad de corrección de errores.
Para ello es útil tener cotas en la distancia mínima, especialmente cotas inferiores.
Existen varias cotas conocidas para la distancia mínima de un código cíclico, pero nos vamos a centrar en la cota de Bose-Ray-Chaudhuri-Hocquenghem, usualmente llamada la cota BCH para abreviar.
Esta cota es esencial para comprender la definición de los códigos BCH que estudiaremos en breve.
La cota BCH depende en los ceros del código y especialmente en la habilidad de encontrar cadenas de ceros <<consecutivos>>.

Asumiremos que \(\mathcal C\) es un código cíclico de longitud \(n\) sobre \(\mathbb F_q\) y que \(\alpha\) es una enésima raíz primitiva de la unidad en \(\mathbb F_{q^t}\), donde \(t = \operatorname{ord}_n(q)\).
Recordemos que \(T\) es un conjunto característico de \(\mathcal C\) siempre y cuando los ceros de \(\mathcal C\) sean \(\{\alpha^{i} \mid i \in T\}\).
Por tanto \(T\) ha de ser una unión de clases \(q\)-ciclotómicas módulo \(n\).
Decimos que \(T\) contiene un conjunto de \(s\) \textit{elementos consecutivos} si existe un conjunto \(\{b, b + 1, \dots, b + s - 1\}\) de \(s\) enteros consecutivos tal que
\[
  \{b, b + 1, \dots, b + s - 1\} \bmod n = S \subseteq T.
\]

Antes de proceder con la cota BCH vamos a enunciar un lema --que será utilizado en la demostración de dicha cota-- sobre el determinante de una matriz de Vandermonde.
Sean \(\alpha_1, \dots, \alpha_s\) elementos de un cuerpo \(\mathbb F\).
La matriz \(s \times s\) \(V = (v_{i, j})\), onde \(v_{i,j} = \alpha_{j}^{i-1}\) se denomina \textit{matriz de Vandermonde}.
La transpueste de esta matriz también es una matriz de Vandermonde.

\begin{lemma}
  El determinante de una matriz Vandermonde \(V\) viene dado por \(\operatorname{det}V = \prod_{1 \leq i < j \leq s}(\alpha_j - \alpha_i)\).
  En particular, \(V\) es no singular si los elementos \(\alpha_1, \dots, \alpha_s\) son todos diferentes dos a dos.
\end{lemma}

Estamos ya en condiciones de presentar y demostrar el teorema de la cota BCH.

\begin{theorem}[Cota BCH]
  Sea \(\mathcal C\) un código cíclico de longitud \(n\) sobre \(\mathbb F_q\) con conjunto característico \(T\).
  Supongamos que \(\mathcal C\) tiene peso mínimo \(d\).
  Asumamos que \(T\) contiene \(\delta - 1\) elementos consecutivos para algún entero \(\delta\).
  Entonces, \(d \geq \delta\).
\end{theorem}

\begin{proof}
  
\end{proof}

Los códigos BCH son códigos cíclicos diseñados para aprovechar la cota BCH.
Nos gustaría poder construir un código cíclico \(\mathcal C\) de longitud \(n\) sobre \(\mathbb F_q\) que tenga a la vez un peso mínimo grande y una dimensión grande.
Tener un peso mínimo grande, basándonos en la cota BCH, se puede conseguir escogiendo un conjunto característico para \(\mathcal C\) que tenga un gran número de elementos consecutivos.

Como la dimensión de \(\mathcal C\) es \(n - |T|\) por el teorema *, nos gustaría que \(|T|\) fuese tan pequeño como sea posible.
Por tanto, si quisiesemos que \(\mathcal C\) tenga distancia mínima de al menos \(\delta\), podemos escoger un conjunto característico tan pequeño como sea posible que sea una unión de clases \(q\)-ciclotómicas con \(\delta - 1\) elementos consecutivos.

Sea \(\delta\) un entero tal que \(2 \leq \delta \leq n\). Un \textit{código BCH} \(\mathcal C\) sobre \(\mathbb F_q\) de longitud \(n\) y \textit{distancia mínima prevista} \(\delta\) es un código cíclico con conjunto característico
\begin{equation}
  \label{eq:bch-conjunto-caracteristico}
  T = C_b \cup C_{b+1} \cup \dots \cup C_{b + \delta - 2},
\end{equation}
donde \(C_i\) es la clase \(q\)-ciclotómica módulo \(n\) que contiene a \(i\).
Por la cota BCH este código tiene distancia mínima prevista al menos \(\delta\).

\begin{theorem}
  Un código BCH de distancia mínima prevista \(\delta\) tiene peso mínimo de al menos \(\delta\).
\end{theorem}

\begin{proof}
  El conjunto característico \ref{eq:bch-conjunto-caracteristico} tiene al menos \(\delta - 1\) elementos.
  El resultado se deduce de la cota BCH.
\end{proof}

Al variar el valor de \(b\) obtenemos distintos códigos con distancias mínimas y dimensiones diferentes.
Cuando \(b = 1\) el código \(\mathcal C\) se dice que es un código BCH \textit{en sentido estricto}.
Como con cualquier código cíclico, si \(n = q^t - 1\) entonces \(\mathcal C\) es un código BCH \textit{primitivo}.

\section{Algoritmo de Peterson-Gorenstein-Zierler}

Fue desarrollado originalmente en 1960 por Peterson (cita) para decodificar códigos BCH binarios, pero fue generalizado poco después por Gorenstein y Zierler para códigos no binarios (cita).

Es un procedimiento de cuatro pasos, de los cuales el segundo es el más complicado y tedioso.