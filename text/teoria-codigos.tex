\chapter{Fundamentos de teoría de códigos}

La teoría de códigos (...). Las definiciones y los resultados comentados en esta sección seguirán lo descrito en \parencite[1-48]{huffman_fundamentals_2003} y \parencite{podesta_introduccion_2006}.

\section{Códigos lineales}

Vamos a comenzar nuestro estudio con los códigos lineales, pues son los más sencillos de comprender. Consideremos el espacio vectorial de todas las \(n\)-tuplas sobre el cuerpo finito \(\mathbb F_q\), al que denotaremos en lo que sigue como \(\mathbb F_q^n\). A los elementos \((a_1, \dots, a_n)\) de \(\mathbb F_q^n\) los notaremos usualmente como \(a_1\!\cdots a_n\).

\begin{definition}
  Un \((n, M)\) \textit{código} \(\mathcal C\) sobre el cuerpo \(\mathbb F_q\) es un subconjunto de \(\mathbb F_q^n\) de tamaño \(M\). A los elementos de \(\mathcal C\) los llamaremos \textit{palabras codificadas} —o \textit{codewords} en inglés—.
\end{definition}

Es necesario añadir más estructura a los códigos para que sean de utilidad.

\begin{definition}
  Decimos que un código \(\mathcal C\) es un código \textit{lineal de longitud \(n\) y rango \(k\)} —abreviado como \([n, k]\) \textit{lineal}— si dicho código es un subespacio vectorial de \(\mathbb F_q^n\) de dimensión \(k\).
\end{definition}

Un código lineal \(\mathcal C\) tiene \(q^k\) palabras codificadas.

\begin{definition}
  Una \textit{matriz generadora} para un \([n, k]\) código \(\mathcal C\) es una matriz \(k \times n\) cuyas filas conforman una base de \(\mathcal C\).
\end{definition}

Veamos un ejemplo de matriz generadora. Consideremos la matriz \(G = \begin{psmallmatrix}
  1 & 1 & 0 \\ 0 & 1 & 1
\end{psmallmatrix} \in \mathcal M_{2 \times 3}(\mathbb F_2)\). Dicha matriz genera un \([3, 2]\) código binario, pues dado \((x_1, x_2)\), se tiene que \[(x_1, x_2) \begin{pmatrix}
  1 & 1 & 0 \\ 0 & 1 & 1
\end{pmatrix} = (x_1, x_1 + x_2, x_2),\] y por tanto este código codifica de la forma \[00 \to 000, \quad 01 \to 011,\quad 10 \to 110,\quad 11 \to 101.\]

\begin{definition}
  Para cada conjunto \(k\) de columnas independientes de una matriz generadora \(G\) el conjunto de coordenadas correspondiente se denomina \textit{conjunto de información} para un código \(\mathcal C\). Las \(r = n - k\) coordenadas restantes se llaman \textit{conjunto redundante}, y el número \(r\), la \textit{redundancia} de \(\mathcal C\).
\end{definition}

Si las primeras \(k\) coordenadas forman un conjunto de información el código tiene una única matriz generadora de la forma \([I_k \mid A]\), donde \(I_k\) es la matriz identidad \(k \times k\) y \(A\) es una matriz \(k \times r\). Esta matriz generadora se dice que está en \textit{forma estándar}.

%Como un código lineal es el subespacio de un espacio vectorial, es el núcleo de una transformación lineal. En particular, existe una matriz \(H\) de dimensiones \(r \times n\), llamada \textit{matriz de comprobación de paridad} para un \([n, k]\) código \(\mathcal C\) definida por \begin{equation}
%  \mathcal C = \left\{x \in \mathbb F_q^n : H \mathbf x^T = 0 %\right\}.
%\end{equation}

Como un código lineal \(\mathcal C\) es un subespacio de un espacio vectorial, podemos calcular el ortogonal a dicho subespacio, obteniendo lo que llamaremos el \textit{código dual} \(\mathcal C^{\perp}\).

\begin{definition}
  El \textit{código dual} \(\mathcal C^{\perp}\) de un código \(\mathcal C\) viene dado por \[\mathcal C^{\perp} = \left\{x \in \mathbb F_q^n : x \cdot c = 0 \quad \forall c \in \mathcal C\right\}.\]
\end{definition}

\begin{definition}
  Sea \(\mathcal C\) un \([n, k]\) código lineal. Una matriz \(H\) se dice que es \textit{matriz de paridad} si es una matriz generadora de \(\mathcal C^{\perp}\).
\end{definition}

\begin{proposition}
  Sea \(H\) la matriz de paridad de un \([n, k]\) código lineal \(\mathcal C\). Entonces, \[\mathcal C = \left\{x \in \mathbb F_q^n : xH^T = 0\right\} = \left\{x \in F_q^n : Hx^T = 0\right\}.\]
\end{proposition}

\begin{proof}
  Sea \(c \in \mathcal C\) una palabra codificada. Sabemos que la podemos expresar como \(c = uG\), donde \(u \in \mathbb F_q^k\) y \(G\) es la matriz generadora de \(\mathcal C\). Tenemos entonces que \(c\cramped{H^T} = uG\cramped{H^T}\) y como \(G\cramped{H^T} = 0\) —por ser H matriz generadora del subespacio ortogonal \(\mathcal C\)— se tiene que \[\mathcal C \subset S_H = \left\{x \in \mathbb F_q^n : Hx^T = 0\right\},\] que es el espacio solución de un sistema de \(n - k\) ecuaciones con \(n\) incógnitas y de rango \(n - k\). Como \(\dim(S_H) = n - (n - k) = k = \dim L\), concluimos que \[L = S_H = \left\{x \in \mathbb F_q^n : Hx^T = 0\right\}.\qedhere\]
\end{proof}

El resultado anterior, junto a la definición anterior, nos conducen al siguiente teorema. 

\begin{theorem}
  Si \(G = [I_k \mid A]\) es una matriz generadora para un \([n, k]\) código \(\mathcal C\) en forma estándar entonces \(H = [-A \mid I_{n-k}]\) es una matriz de paridad para \(\mathcal C\).
\end{theorem}

Un código se dice \textit{autoortogonal} cuando \(\mathcal C \subseteq \mathcal C^{\perp}\), y \textit{autodual} cuando \(\mathcal C = \mathcal C^{\perp}\).

\subsection{Distancias y pesos}

\begin{definition}
  La \textit{distancia de Hamming} \(\operatorname{d}(\symbf{x}, \symbf{y})\) entre dos vectores \(\symbf{x}, \symbf{y} \in \mathbb F_q^n\) se define como el número de coordenadas en las que difieren \(\symbf{x}\) e \(\symbf{y}\).
\end{definition}

\begin{theorem}
  La función de distancia \(\operatorname{d}(\symbf{x}, \symbf{y})\) verifica las siguientes propiedades.
  \begin{enumerate}
    \item No negatividad: \(\operatorname{d}(\symbf{x}, \symbf{y}) \geq 0\) para todo \(\symbf{x}, \symbf{y}\in \mathbb F_q^n\).
    \item \(\operatorname{d}(\symbf{x}, \symbf{y}) = 0\) si y solo si \(\symbf{x} = \symbf{y}\).
    \item Simetría: \(\operatorname{d}(\symbf{x}, \symbf{y}) = \operatorname{d}(\symbf{y}, \symbf{x})\) para todo \(\symbf{x}, \symbf{y}\in \mathbb F_q^n\).
    \item Desigualdad triangular: \(\operatorname{d}(\symbf{x}, \symbf{z}) \leq \operatorname{d}(\symbf{x}, \symbf{y}) + \operatorname{d}(\symbf{y}, \symbf{z})\) para todo elemento \(\symbf{x}, \symbf{y}, \symbf{z}\in \mathbb F_q^n\).
  \end{enumerate}
\end{theorem}

La \textit{distancia (mínima)} de un código \(\mathcal C\) es la menor distancia posible entre dos palabras codificadas distintas. 
Es importante a la hora de determinar la capacidad de corrección de errores del código \(\mathcal C\), pues como veremos más tarde, a mayor distancia mínima, mayor número de errores en el código se pueden corregir.

\begin{definition}
  El \textit{peso de Hamming} \(\operatorname{wt}(\symbf{x})\) de un vector \(\symbf{x}\) es el número de coordenadas distintas de cero de \(\symbf{x}\).
\end{definition}

\begin{theorem}
  Si \(\symbf{x}, \symbf{y} \in \mathbb F_q^n\), entonces \(\operatorname{d}(\symbf{x}, \symbf{y}) = \operatorname{wt}(\symbf{x} - \symbf{y})\).
  Si \(\mathcal C\) es un código lineal, la distancia mímina es igual al peso mínimo de las palabras codificadas de \(\mathcal C\) distintas de cero.
\end{theorem}

Como consecuencia de este teorema —para códigos lineales— la distancia mínima también se llama \textit{peso mínimo} del código.
Si el peso mínimo \(d\) de un \([n,k]\) código es conocida, nos referiremos a él como un \([n,k,d]\) código.

\begin{definition}
  Sea \(A_i(\mathcal C)\) —que abreviaremos \(A_i\)— el número de palabras codificadas de peso \(i\) en \(\mathcal C\).
  Para cada \(0 \leq i \leq n\), la lista \(A_i\) se denomina \textit{distribución de peso} o \textit{espectro de peso} de \(\mathcal C\).
\end{definition}

\begin{example}
  Sea \(\mathcal C\) el código binario con matriz generadora
  \[
    G = \begin{pmatrix}
      1 & 1 & 0 & 0 & 0 & 0\\
      0 & 0 & 1 & 1 & 0 & 0 \\
      0 & 0 & 0 & 0 & 1 & 1
    \end{pmatrix}.
  \]
  Dado \((x_1, x_2, x_3)\), se tiene que \[(x_1, x_2, x_3) \begin{pmatrix}
    1 & 1 & 0 & 0 & 0 & 0\\
      0 & 0 & 1 & 1 & 0 & 0 \\
      0 & 0 & 0 & 0 & 1 & 1
  \end{pmatrix} = (x_1, x_1, x_2, x_2, x_3, x_3),\] y por tanto este código codifica de la forma 
  \[
    000 \to 000000, \quad 
    001 \to 000011,\quad 
    010 \to 001100,\quad 
    011 \to 001111,
  \]
  \[
    100 \to 110000, \quad 
    101 \to 110011,\quad 
    110 \to 111100,\quad 
    111 \to 111111.
  \]
  Luego la distribución de peso de \(\mathcal C\) es \(A_0 = A_6 = 1\) y \(A_2 = A_4 = 3\).
  Usualmente solo se listan los \(A_i\) que son distintos de cero.
\end{example}

\begin{theorem}
  Sea \(\mathcal C\) un \([n,k,d]\) código sobre \(\mathbb F_q\).
  Entonces, \begin{enumerate}
    \item \(A_0(\mathcal C) + A_1(\mathcal C) + \cdots + A_n(\mathcal C) = q^k\).
    \item \(A_0(\mathcal C) = 1\) y \(A_1(\mathcal C) = A_2(\mathcal C) = \cdots = A_{d-1}(\mathcal C) = 0\).
  \end{enumerate}
\end{theorem}

% Theorem 1.4.13, Corollary 1.4.14 (Huffman-Pless), p.12-13

\begin{theorem}
  Sea \(\mathcal C\) un código lineal con matriz de paridad \(H\). Si \(\symbf{c} \in \mathcal C\), las columnas de \(H\) que se corresponden con coordenadas no nulas de \(\symbf{c}\) son linealmente independientes.
  Recíprocamente, si entre \(w\) columnas de \(H\) existe una relación de dependencia lineal con coeficientes no nulos, entonces hay una palabra codificada en \(\mathcal C\) de peso \(w\) cuyas coordenadas no nulas se corresponden con dichas columnas.
\end{theorem}

\begin{corollary}
  \label{cor:peso-minimo-columnas-dependientes}
  Un código lineal tiene peso mínimo \(d\) si y solo si su matriz de paridad tiene un conjunto de \(d\) columnas linealmente dependientes pero no tiene un conjunto de \(d-1\) columnas linealmente dependientes.
\end{corollary}

% TODO: teoremas sobre códigos que cumplen ciertas condiciones, no sé si merece Huffman 9-11

\section{Ejemplos de códigos}

\subsection{Códigos de Hamming}

Consideremos una matriz \(r \times (2^r - 1)\) cuyas columnas son los números \(1, 2, 3, \dots, 2^{r-1}\) escritos en binario. 
Dicha matriz es la matriz de paridad de un \([n=2^{r-1}, k=n-r]\) código binario.
A los códigos de esta forma los llamaremos códigos de Hamming de longitud \(n = 2^{r-1}\) y los denotamos por \(\mathcal H_r\) o \(\mathcal H_{2,r}\).

Como las columnas son distintas y no dula, la distancia es al menos \(3\) por el corolario \ref{cor:peso-minimo-columnas-dependientes}.
Además, como las columnas correspondientes a los números \(1, 2, 3\) son linealmente independientes, la distancia mínima es 3 por el mismo corolario.
Podemos decir por tanto que los códigos de Hamming \(\mathcal H_r\) son \([2^{r-1}, 2^{r-1-r}, 3]\) códigos binarios.

Podemos generalizar esta definición y definir los códigos de Hamming \(\mathcal H_{q,r}\) sobre un cuerpo finito arbitrario \(\mathbb F_q\). 
Para \(r \geq 2\) un código \(\mathcal H_{q,r}\) tiene matriz de paridad \(H_{q,r}\), cuyas columnas están compuestas por un vector no nulo por cada uno de los subespacios de dimensión \(1\) de \(\mathbb F_q^r\).
Hay \((q^r-1)/(q-1)\) subespacios de dimensión \(1\), por lo que \(\mathcal H_{q,r}\) tiene longitud \(n = (q^r-1)/(q-1)\), dimensión \(n-r\) y redundancia \(r\).
Como todas las columnas son independientes unas de otras, \(\mathcal H_{q,r}\) tiene peso mínimo al menos 3.
Si sumamos dos vectores no nulos de dos subespacios unidimensionales distintos obtenemos un vector no nulo de un tercer subespacio unidimensional, por lo que \(\mathcal H_{q,r}\) tiene peso mínimo 3. 
Cuando \(q = 2\), \(\mathcal H_{2,r}\) es el código \(\mathcal H_r\).

% TODO
% - por qué los códigos de Hamming son importantes
% - en qué se utilizan los códigos de Hamming

\section{Códigos cíclicos}

Un código lineal \(\mathcal C\) de longitud \(n\) sobre \(\mathbb F_q\) es \textit{cíclico} si para cada vector \(\mathbf c = c_0\dots c_{n-2}c_{n-1}\) en \(\mathcal C\), el vector \(c_{n-1}c_0\dots c_{n-2}\) --obtenido a partir de \(\mathbf c\) desplazando cíclicamente las coordenadas, llevando \(i \mapsto i +1 \bmod n\)-- también está en \(\mathcal C\).
Pensamos en la posición de las coordenadas de forma cíclica, pues al llegar a \(n -1\) se comienza de nuevo en \(0\).
Al hablar de <<coordenadas consecutivas>> siempre tendremos en cuenta esta ciclicidad.

% FIXME: revisar uso palabra "ciclicidad"

Cuando trabajemos con códigos cíclicos representaremos las palabras codificadas como polinomios.
Existe una biyección evidente entre el vector \(\mathbf c = c_0c_1\dots c_{n-1}\) en \(\mathbb F_q\) y los polinomios de la forma \(c(x) = c_0 + c_1x + \dots c_{n-1}x^{n-1}\) en \(\mathbb F_q[x]\) de grado al menos \(n-1\).
Obsérvese que dado un polinomio \(c(x)\) descrito como antes, el polinomio \(xc(x) = c_{n-1}x^n + c_0x + c_1x^2 + \dots + c_{n-2}x^{n-1}\) equivale a representar la palabra codificada \(\mathbf c\) desplazada una posición a la derecha, siempre que \(x^n\) fuese igual a \(1\).

Formalmente, el hecho de que un código \(\mathcal C\) sea invariante bajo un desplazamiento cíclico implica que si \(c(x)\) está en \(\mathcal C\), también ha de estar \(xc(x)\), siempre que multipliquemos módulo \(x^n -1\). 
Esto nos sugiere que el contexto para estudiar códigos cíclicos es el anillo cociente \(\mathcal R_n = \mathbb F_q[x]/(x^n - 1)\).

Por tanto, bajo la correspondencia vectores-polinomios que hemos descrito antes, los códigos cíclcos son ideales de \(\mathcal R_n\), y los ideales de \(\mathcal R_n\) son códigos cíclicos.
En consecuencia, el estudio de los códigos cíclicos en \(\mathbb F_q^n\) es equivalente al estudio de los ideales en \(\mathcal R_n\), que depende de la factorización de \(x^n-1\).

\subsection{Factorización de \(x^n -1\)}

Existen dos posibilidades: o bien \(x^n -1\) tiene factores irreducibles repetidos, o no.

Para factorizar \(x^n - 1\) sobre \(\mathbb F_q\) es útil considerar la extensión de cuerpos \(\mathbb F_{q^t}\) de \(\mathbb F_q\) que contenga todas sus raíces.
\(\mathbb F_{q^t}\) debe contener una enésima raíz primitiva de la unidad, que ocurre cuando \(n \mid (q^t - 1)\) por el teorema... 
% TODO: referenciar teorema (Th 3.3.3, ECC)

\subsection{.}

Vamos a ver que hay una correspondencia biyectiva entre los códigos cíclicos en \(\mathcal R_n\) y los polinomios mónicos divisores de \(x^n-1\).

\begin{theorem}
  \label{th:corr-cod-div}
  Sea \(\mathcal C\) un ideal de \(\mathcal R_n\), es decir, un código cíclico de longitud \(n\). Entonces:
  \begin{enumerate}
    \item Existe un único polinomio mónico \(g(x)\) de grado mínimo en \(\mathcal C\).\label{thi:corr-codc-div:monico-minimo}
    \item El polinomio descrito en (\ref{thi:corr-codc-div:monico-minimo}) genera \(\mathcal C\), es decir, \(\mathcal C = \langle g(x)\rangle\).
    \item El polinomio descrito en (\ref{thi:corr-codc-div:monico-minimo}) verifica que \(g(x) \mid x^n -1\).\label{thi:corr-codc-div:div-xn-1}
  \end{enumerate}
  Sea \(k = n - \operatorname{gr} g(x)\) y sea \(g(x) = \sum_{i_0}^{n-k}g_ix^{i}\), donde \(g_{n-k} = 1\). Entonces:
  \begin{enumerate}[resume]
    %\item La dimensión de \(\mathcal C\) es \(k\) y \(\{g(x), xg(x), \dots, x^{k-1}g(x)\}\) es una base de \(\mathcal C\).
    %\item Cada elemento de \(\mathcal C\) se puede expresar como producto de \(g(x)\) por un polinomio \(f(x)\), donde \(f(x) = 0\) o bien \(\operatorname{gr} f(x) < k\).
    \item \label{thi:corr-codc-div:dim-ideal} Se verifica que \[
      \mathcal C = \langle g(x) \rangle = \{f(x)g(x) : \operatorname{gr} f(x) < k\}.
    \]
    \item El conjunto \(\{g(x), xg(x), \dots, x^{k-1}g(x)\}\) es una base de \(\mathcal C\) y \(\mathcal C\) tiene dimensión \(k\).
    \item La matriz \(G\) dada por \begin{align*}
      G &= \begin{bmatrix}
        g_0 & g_1 & g_2 & \dots & \dots & g_{n-k} & 0 & 0 & \dots & 0 \\
        0 & g_0 & g_1 & g_2 & \dots & \dots & g_{n-k} & 0 & \dots & 0 \\
        0 & 0 & g_0 & g_1 & g_2 & \dots & \dots & g_r & \ddots & \vdots \\
        \vdots & \vdots & \ddots & \ddots & \ddots & \ddots & & & \ddots & 0\\
        0 & 0 & \dots & 0 & g_0 & g_1 & g_2 & \dots & \dots & g_{n-k} 
      \end{bmatrix},
      % \\
      %   &\iff \begin{bmatrix}
      %     g(x) & & & \\
      %      & xg(x) & & \\
      %      & & \dots & \\
      %      & & & x^{k-1}g(x)
      %   \end{bmatrix}
    \end{align*}
    donde cada fila es un desplazamiento cíclico de la fila previa, es una matriz generadora de \(\mathcal C\).
    \item Si \(\alpha\) es una raíz enésima primitiva de la unidad en alguna extensión de cuerpos de \(\mathbb F_q\) entonces \[
      g(x) = \prod_s M_{\alpha^s}(x),
    \] siendo dicho producto sobre un subconjunto de representantes de las clases \(q\)-ciclotómicas módulo \(n\).
  \end{enumerate}
\end{theorem}

\begin{proof}
  Veamos la demostración apartado por apartado.
  \begin{enumerate}
    \item Supongamos que \(\mathcal C\) contiene dos polinomios mónicos distintos, \(g_1(x)\) y \(g_2(x)\), ambos de grado mínimo \(r\). 
    Entonces, \(g_1(x) - g_2(x)\) es un polinomio no nulo de grado menor que \(r\), lo que es absurdo. 
    Existe por tanto un único polinomio de grado mínimo \(r\) en \(\mathcal C\), como queríamos.
    \item Como \(g(x) \in \mathcal C\) y \(\mathcal C\) es un ideal, tenemos que \(\langle g(x)\rangle \subset \mathcal C\). 
    Por otra parte, dado \(p(x) \in \mathcal C\) el algoritmo de división nos da elementos \(q(x), r(x)\) tales que \(p(x) = q(x)g(x) + r(x)\), de forma que o bien \(r(x) = 0\) o bien \(\operatorname{gr} r(x) < \operatorname{gr} g(x)\). 
    Como podemos expresar \(r(x)\) de la forma \(r(x) = p(x) - q(x)g(x) \in \mathcal C\) y tiene grado menor que \(\operatorname{gr} g(x)\), al ser este último de grado mínimo necesariamente ha de darse que \(r(x) = 0\).
    Por tanto, \(p(x) = q(x)g(x) \in \langle g(x) \rangle\) y \(\mathcal C \subset \langle g(x) \rangle\).
    En consecuencia, \(\langle g(x) \rangle = \mathcal C\).
    \item Por el algoritmo de división, al dividir \(x^n - 1\) por \(g(x)\) tenemos que \(x^n - 1 = q(x)g(x) + r(x)\). De nuevo, o bien \(r(x) = 0\) o bien \(\operatorname{gr} r(x) < \operatorname{gr} g(x)\).
    Como en \(\mathcal R_n\) se tiene que \(x^n - 1 = 0 \in \mathcal C\), necesariamente \(r(x) \in \mathcal C\).
    Esto supone una contradicción, a menos que \(r(x) = 0\).
    % FIXME: por qué supone una contradicción??? mirar 24-2-20 en el cuaderno
    En consecuencia, \(g(x) \mid x^n - 1\).
    \item El ideal generado por \(g(x)\) es \(\langle g(x) \rangle = \{f(x)g(x) : f(x) \in \mathcal R_n\}\).
    Queremos ver que podemos restringir los polinomios \(f(x)\) a aquellos que tengan grado menor que \(k\).
    Por (\ref{thi:corr-codc-div:div-xn-1}) sabemos que \(x^n-1 = h(x)g(x)\) para algún polinomio \(h(x)\) que tenga grado \(k = n - \operatorname{gr} g(x)\).
    Dividimos entonces \(f(x)\) por este polinomio \(h(x)\) y por el algoritmo de división obtenemos \(f(x) = q(x)h(x) + r(x)\), donde \(\operatorname{gr} r(x) < \operatorname{gr} h(x) = k\).
    Entonces, tenemos \begin{align*}
      f(x)g(x) &= q(x)h(x)g(x) + r(x)g(x)\\
               &= q(x)(x^n - 1) + r(x)g(x),
    \end{align*}
    luego \(f(x)g(x) = r(x)g(x)\), y puesto que antes ya hemos visto que \(\operatorname{gr} r(x) < k\), hemos obtenido lo que buscábamos.
    \item A partir de (\ref{thi:corr-codc-div:dim-ideal}) tenemos que el conjunto \[\{g(x), xg(x), \dots, x^{k-1}g(x)\}\] genera \(\mathcal C\), y como es linealmente independiente, forma una base de \(\mathcal C\).
    Esto demuestra también que la dimensión de \(\mathcal C\) es \(k\).
    \item La matriz \(G\) es matriz generadora de \(\mathcal C\) pues \[\{g(x), xg(x), \dots, x^{k-1}g(x)\}\] es una base de \(\mathcal C\).
    \item TODO. % TODO: apartado 7, tiene que ver con la factorización de x^n - 1 que todavía no he comentado
  \end{enumerate}
\end{proof}

Este teorema nos muestra que existe un polinomio mónico \(g(x)\) que divide a \(x^n - 1\) y genera \(\mathcal C\).
Vamos a ver a continuación que dicho polinomio es único.

\begin{corollary}
  \label{cor:pol-gen-unico}
  Sea \(\mathcal C\) un código cíclico en \(\mathcal R_n\) distinto de cero.
  Son equivalentes:
  \begin{enumerate}
    \item El polinomio \(g(x)\) es el polinomio mónico de menor grado en \(\mathcal C\).
    \item Podemos expresar \(\mathcal C\) como \(\mathcal C = \langle g(x)\rangle\), \(g(x)\) es mónico y \(g(x) \mid (x^n -1)\).
  \end{enumerate}
\end{corollary}

\begin{proof}
  Que (1) implica (2) ya lo hemos probado en el teorema \ref{th:corr-cod-div}. 
  Veamos que partiendo de (2) obtenemos (1). 
  Sea \(g_1(x)\) el polinomio mónico de menor grado en \(\mathcal C\).
  Por el teorema \ref{th:corr-cod-div}, \(g_1(x) \mid g(x)\) en \(\mathbb F_q[x]\) y \(\mathcal C = \langle g_1(x)\rangle\).
  Como \(g_1(x) \in \mathcal C = \langle g(x) \rangle\), podemos expresarlo como \(g_1(x) = g(x)a(x) \bmod x^n - 1\), luego tenemos que \(g_1(x) = g(x)a(x) + (x^n - 1)b(x)\) en \(\mathbb F_q[x]\).
  Por otro lado, como \(g(x) \mid (x^n - 1)\), tenemos que \(g(x) \mid g(x)a(x) + (x^n-1)b(x)\), o lo que es lo mismo, que \(g(x) \mid g_1(x)\). 
  En consecuencia, como \(g_1(x)\) y \(g(x)\) son ambos mónicos y dividen el uno al otro en \(\mathbb F_q[x]\), son necesariamente iguales.
\end{proof}

A este polinomio lo llamamos \textit{polinomio generador} del código cíclico \(\mathcal C\).
Por el corolario anterior, este polinomio es tanto el polinomio mónico en \(\mathcal C\) de grado mínimo como el polinomio mónico que divide a \(x^n - 1\) y genera a \(\mathcal C\).
Existe por tanto una correspondencia biunívoca entre los códigos cíclicos distintos de cero y los divisores de \(x^n - 1\) distintos de él mismo.
Para extender dicha correspondencia entre todos los códigos cíclicos en \(\mathcal R_n\) y todos los divisores mónicos de \(x^n - 1\) definimos como polinomio generador del código cíclico \(\{\mathbf 0\}\) el polinomio \(x^n - 1\). 
Esta correspondencia biyectiva nos conduce al siguiente corolario.

\begin{corollary}
  El número de códigos cíclicos en \(\mathcal R_n\) es \(2^m\), donde \(m\) es el número de clases \(q\)-ciclotómicas módulo \(n\).
  Es más, las dimensiones de los códigos cíclicos en \(\mathcal R_n\) son todas sumas de tamaños de las clases \(q\)-ciclotómicas módulo \(n\).
\end{corollary}

\begin{proof}
  % TODO: demostrar? en el libro no viene demostrado y tampoco entiendo muy bien la segunda afirmación
\end{proof}

% TODO: ejemplo? ejemplo 4.2.4 del libro

El siguiente resultado nos muestra la relación entre dos polinomios generadores cuando un código es subcódigo de otro.

\begin{corollary}
  Sean \(\mathcal C_1\) y \(\mathcal C_2\) códigos cíclicos sobre \(\mathbb F_q\) con polinomios generadores \(g_1(x)\) y \(g_2(x)\), respectivamente.
  Entonces, \(\mathcal C_1 \subset \mathcal C_2 \) si y solo si \(g_2(x) \mid g_1(x)\).
\end{corollary}

% TODO: resultados sobre duales de códigos cíclicos (4.2.6, 4.2.7)

\subsection{Codificación y decodificación de códigos cíclicos}

Los códigos cíclicos son más sencillos de decodificar que otros tipos de códigos debido a su estructura adicional.
Vamos a ver a continuación tres tipos de codificación de códigos cíclicos.
Consideraremos un código cíclico \(\mathcal C\) de longitud \(n\) sobre \(\mathbb F_q\) con polinomio generador \(g(x)\) de grado \(n - k\), por lo que \(\mathcal C\) tiene dimensión \(k\).

\paragraph{Codificación no-sistemática}

Esta forma de codificación está basada en la técnica natural de codificación que describimos en la sección (
  %TODO: referencia
).
Sea \(G\) la matriz generadora obtenida a partir de los desplazamientos de \(g(x)\) descrita en el teorema \ref{th:corr-cod-div}.
Dado el mensaje \(\mathbf m \in \mathbb F_q^k\), lo codificamos como la palabra codificada \(\mathbf c = \mathbf mG\).
De igual forma, si \(m(x)\) y \(c(x)\) son los polinomios en \(\mathbb F_q[x]\) asociados a \(\mathbf{m}\) y \(\mathbf c\), entonces \(c(x) = m(x)g(x)\).

\paragraph{Codificación sistemática}

El polinomio \(m(x)\) asociado a un mensaje \(\mathbf m\) tendrá como mucho grado \(k -1\).
Por tanto, el polinomio \(n^{n-k}m(x)\) tendrá como mucho grado \(n - 1\) y sus primeros \( n - k\) coeficientes son nulos.
Por tanto, el mensaje está contenido en los coeficientes de \(x^{n-k}, x^{n-k+1}, \dots, x^{n-1}\).
Por el algoritmo de división tenemos que
\[x^{n-k}m(x) = g(x)a(x) + r(x), \qquad \text{donde } \operatorname{gr} r(x) < n - k \text{ o } r(x) = 0.\]
Sea \(c(x) = x^{n-k}m(x) - r(x)\).
Como \(c(x)\) es múltiplo de \(g(x)\), \(c(x) \in \mathcal C\).
El polinomio \(c(x)\) difiere de \(x^{n-k}m(x)\) en los coeficientes de \(1, x, \dots, x^{n-k-1}\) ya que \(\operatorname{gr} r(x) < n-k\).
Por tanto, \(c(x)\) contiene el mensaje \(\mathbf m\) en los coeficientes de los términos de grado al menos \(n - k\).

\paragraph{Codificación sistemática usando el código dual}

Aquí vamos

\begin{example}
  Sea \(\mathcal C\) un código cíclico de longitud 15 con polinomio generador \(g(x) = (1 + x + x^4)(1 + x + x^2 + x^3 + x^4)\). Vamos a ver su codificación con los tres métodos descritos.
\end{example}

\subsection{Idempotentes y multiplicadores}

% TODO: something something sobre que R_n es semisimple y Wedderburn Structure Theorems

Cada código cíclico en \(\mathcal R_n\) contiene un único idempotente que genera el ideal.
Este elemento se denomina \textit{idempotente generador} del código cíclico.
En el siguiente teorema probaremos este hecho y mostraremos además un método para determinar el idempotente generador de un código cíclico.

\begin{theorem}
  Sea \(\mathcal C\) un código cíclico en \(\mathcal R_n\). Entonces:
  \begin{enumerate}
    \item Existe un único idempotente \(e(x) \in \mathcal C\) tal que \(\mathcal C = \langle e(x)\rangle\).
    \item Si \(e(x)\) es un idempotente no nulo en \(\mathcal C\), entonces \(\mathcal C = \langle e(x)\rangle\) si y solo si \(e(x)\) es la unidad de \(\mathcal C\).
  \end{enumerate}
\end{theorem}

\begin{proof}
  Si \(\mathcal C\) es el código cero, entonces el idempotente es el cero, con lo que (1) está claro y (2) no se aplica a este caso. 
  Veamos entonces la demostración por apartados suponiendo que \(\mathcal C\) es distinto de cero.
  \begin{enumerate}
    \item Supongamos primero que \(e(x)\) es una unidad en \(\mathcal C\). 
    Entonces, \(\langle e(x)\rangle \subset \mathcal C\), ya que \(\mathcal C\) es un ideal.
    Si \(c(x) \in \mathcal C\), entonces \(c(x)e(x) = c(x)\) en \(\mathcal C\).
    En consecuencia, \(\langle e(x)\rangle = \mathcal C\).
    Por otro lado, supongamos que \(e(x)\) es un idempotente distinto de cero y tal que \(\mathcal C = \langle e(x)\rangle\).
    Entonces, cada elemento \(c(x)\) lo podemos escribir como \(c(x) = f(x)e(x)\).
    Pero se tiene que \(c(x)e(x) = f(x)(e(x))^2 = f(x)e(x) = c(x)\), luego \(e(x)\) es la unidad de \(\mathcal C\).
    \item Tenemos que probar la existencia y la unicidad.
    Comenzamos con la existencia.
    Sea \(g(x)\) el polinomio generador dde \(\mathcal C\).
    Entonces, sabemos que \(g(x) \mid (x^n - 1)\) por el teorema \ref{th:corr-cod-div}.
    Tomemos \(h(x) = (x^n - 1)/g(x)\).
    Sabemos que \(\operatorname{mcd}(g(x), h(x)) = 1\) en \(\mathbb F_q[x]\), ya que \(x^n - 1\) tiene todas sus raíces distintas.
    En consecuencia, el algoritmo de Euclides %TODO: está explicado?
    nos proporciona los polinomios \(a(x),b(x) \in \mathbb F_q[x]\) tales que \(a(x)g(x) + b(x)h(x) = 1\).
    Llamemos \(e(x) \equiv a(x)g(x) \bmod x^n - 1\), que será el representante de dicha clase de equivalencia en \(\mathcal R_n\).
    Entonces, en \(\mathcal R_n\),
    \begin{align*}
      e(x)^2 &\equiv (a(x)g(x))(1 - b(x)h(x)) \bmod x^n - 1\\
        &\equiv a(x)g(x) - a(x)g(x)b(x)h(x) \bmod x^n - 1\\
        &\equiv a(x)g(x) - a(x)b(x)(x^n - 1) \bmod x^n - 1\\
        &\equiv a(x)g(x) \bmod x^n - 1\\
        &\equiv e(x) \bmod x^n - 1.
    \end{align*}
    Por tanto, este elemento \(e(x)\) es idempotente.
    Veamos ahora que si \(c(x) \in \mathcal C\), entonces \(c(x) = f(x)g(x)\), luego
    \begin{align*}
      c(x)e(x) &= f(x)g(x)(1 - b(x)h(x))\\
        &\equiv f(x)g(x) \bmod x^n - 1\\
        &\equiv c(x) \bmod x^n - 1,
    \end{align*}
    por lo que \(e(x)\) es la unidad en \(\mathcal C\).
    En consecuencia, podemos deducir la existencia a partir de (2).
    Veamos ahora la unicidad. Por (2), si tenemos dos elementos idempotentes \(e_1(x)\) y \(e_2(x)\) que generan \(\mathcal C\), ambos han de ser unidades, y en consecuencia se tiene que \(e_1(x) = e_1(x)e_2(x) = e_2(x)\), con lo que podemos deducir la unicidad.
  \end{enumerate}
\end{proof}

Deducimos por tanto que un método para encontrar el idempotente generador \(e(x)\) de un código cíclico \(\mathcal C\) a partir del polinomio generador \(g(x)\) es resolver la ecuación \[1 = a(x)g(x) + b(x)h(x)\] para \(a(x)\) utilizando el algoritmo de Euclides, donde \(h(x) = (x^n - 1)/g(x)\).
Entonces, reduciendo \(a(x)g(x)\) módulo \(x^n - 1\) obtenemos el idempotente \(e(x)\) que buscamos.
De hecho, el siguiente teorema nos muestra además que podemos obtener \(g(x)\) a partir de \(e(x)\). 

\begin{theorem}
  Sea \(\mathcal C\) un código cíclico sobre \(\mathbb F_q\) con idempotente generador \(e(x)\).
  Entonces, el polinomio generador de \(\mathcal C\) es \(g(x) = \operatorname{mcd}(e(x), x^n - 1)\), calculado en \(\mathbb F_q[x]\). 
\end{theorem}

\begin{proof}
  Sea \(d(x) = \operatorname{mcd}(e(x), x^n - 1)\) en \(\mathbb F_q[x]\) y sea \(g(x)\) el polinomio generador de \(\mathcal C\).
  Como \(d(x) \mid e(x)\), podemos expresarlo como \(e(x) = d(x)k(x)\) para algún \(k(x) \in \mathbb F_q[x]\).
  Por tanto cada elemento de \(\mathcal C = \langle e(x) \rangle\) es también múltiplo de \(d(x)\), por lo que \(\mathcal C \subset \langle d(x) \rangle\).
  Por el teorema \ref{th:corr-cod-div} tenemos que en \(\mathbb F_q[x]\), \(g(x) \mid (x^n -1)\) y que \(g(x) \mid e(x)\), ya que \(e(x) \in \mathcal C\).
  Luego, por la proposición (TODO: proposición, ejercicio 158) tenemos que \(g(x) \mid d(x)\) y en consecuencia \(d(x) \in \mathcal C\).
  Por tanto, \(\langle d(x) \rangle \subseteq \mathcal C\) y deducimos entonces que \(\mathcal C = \langle d(x) \rangle\).
  Como \(d(x)\) es divisor mónico de \(x^n - 1\) y genera a \(\mathcal C\), necesariamente \(d(x) = g(x)\) por el corolario \ref{cor:peso-minimo-columnas-dependientes}. 
\end{proof}

% MAYBE: ejemplos de códigos cíclicos 4.3.4, 4.3.5??

El siguiente teorema nos muestra --igual que para el polinomio generador-- que el idempotente generador y sus primeros \(k - 1\) desplazamientos cíclicos forman una base de un código cíclico.

\begin{theorem}
  Sea \(\mathcal C\) un \([n, k]\) código cíclico con idempotente generador \(e(x) = \sum_{i=0}^{n-1}e_ix^i\).
  Entonces, la matriz \(k \times n\)
  \[
    \begin{pmatrix*}
      e_0 & e_1 & e_2 & \dots & e_{n-2} & e_{n-1} \\
      e_{n-1} & e_0 & e_1 & \dots & e_{n-3} & e_{n-2} \\
       & & & \vdots & & \\
      e_{n-k+1} & e_{n-k+2} & e_{n-k+3} & \dots & e_{n-k-1} & e_{n-k}
    \end{pmatrix*}
  \] es una matriz generadora de \(\mathcal C\).
\end{theorem}

\begin{proof}
  % TODO: demostración de este teorema
\end{proof}

\section{Algoritmo de Peterson-Gorenstein-Zierler}