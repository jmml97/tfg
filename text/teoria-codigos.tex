\chapter{Fundamentos de teoría de códigos}

La teoría de códigos (...). Las definiciones y los resultados comentados en esta sección seguirán lo descrito en \parencite[1-48]{huffman_fundamentals_2003} y \parencite{podesta_introduccion_2006}.

\section{Códigos lineales}

Vamos a comenzar nuestro estudio con los códigos lineales, pues son los más sencillos de comprender. Consideremos el espacio vectorial de todas las \(n\)-tuplas sobre el cuerpo finito \(\mathbb F_q\), al que denotaremos en lo que sigue como \(\mathbb F_q^n\). A los elementos \((a_1, \dots, a_n)\) de \(\mathbb F_q^n\) los notaremos usualmente como \(a_1\!\cdots a_n\).

\begin{definition}
  Un \((n, M)\) \textit{código} \(\mathcal C\) sobre el cuerpo \(\mathbb F_q\) es un subconjunto de \(\mathbb F_q^n\) de tamaño \(M\). A los elementos de \(\mathcal C\) los llamaremos \textit{palabras codificadas} —o \textit{codewords} en inglés—.
\end{definition}

Es necesario añadir más estructura a los códigos para que sean de utilidad.

\begin{definition}
  Decimos que un código \(\mathcal C\) es un código \textit{lineal de longitud \(n\) y rango \(k\)} —abreviado como \([n, k]\) \textit{lineal}— si dicho código es un subespacio vectorial de \(\mathbb F_q^n\) de dimensión \(k\).
\end{definition}

Un código lineal \(\mathcal C\) tiene \(q^k\) palabras codificadas.

\begin{definition}
  Una \textit{matriz generadora} para un \([n, k]\) código \(\mathcal C\) es una matriz \(k \times n\) cuyas filas conforman una base de \(\mathcal C\).
\end{definition}

Veamos un ejemplo de matriz generadora. Consideremos la matriz \(G = \begin{psmallmatrix}
  1 & 1 & 0 \\ 0 & 1 & 1
\end{psmallmatrix} \in \mathcal M_{2 \times 3}(\mathbb F_2)\). Dicha matriz genera un \([3, 2]\) código binario, pues dado \((x_1, x_2)\), se tiene que \[(x_1, x_2) \begin{pmatrix}
  1 & 1 & 0 \\ 0 & 1 & 1
\end{pmatrix} = (x_1, x_1 + x_2, x_2),\] y por tanto este código codifica de la forma \[00 \to 000, \quad 01 \to 011,\quad 10 \to 110,\quad 11 \to 101.\]

\begin{definition}
  Para cada conjunto \(k\) de columnas independientes de una matriz generadora \(G\) el conjunto de coordenadas correspondiente se denomina \textit{conjunto de información} para un código \(\mathcal C\). Las \(r = n - k\) coordenadas restantes se llaman \textit{conjunto redundante}, y el número \(r\), la \textit{redundancia} de \(\mathcal C\).
\end{definition}

Si las primeras \(k\) coordenadas forman un conjunto de información el código tiene una única matriz generadora de la forma \([I_k \mid A]\), donde \(I_k\) es la matriz identidad \(k \times k\) y \(A\) es una matriz \(k \times r\). Esta matriz generadora se dice que está en \textit{forma estándar}.

%Como un código lineal es el subespacio de un espacio vectorial, es el núcleo de una transformación lineal. En particular, existe una matriz \(H\) de dimensiones \(r \times n\), llamada \textit{matriz de comprobación de paridad} para un \([n, k]\) código \(\mathcal C\) definida por \begin{equation}
%  \mathcal C = \left\{x \in \mathbb F_q^n : H \boldsymbol x^T = 0 %\right\}.
%\end{equation}

Como un código lineal \(\mathcal C\) es un subespacio de un espacio vectorial, podemos calcular el ortogonal a dicho subespacio, obteniendo lo que llamaremos el \textit{código dual} \(\mathcal C^{\perp}\).

\begin{definition}
  El \textit{código dual} \(\mathcal C^{\perp}\) de un código \(\mathcal C\) viene dado por \[\mathcal C^{\perp} = \left\{x \in \mathbb F_q^n : x \cdot c = 0 \quad \forall c \in \mathcal C\right\}.\]
\end{definition}

\begin{definition}
  Sea \(\mathcal C\) un \([n, k]\) código lineal. Una matriz \(H\) se dice que es \textit{matriz de paridad} si es una matriz generadora de \(\mathcal C^{\perp}\).
\end{definition}

\begin{proposition}
  Sea \(H\) la matriz de paridad de un \([n, k]\) código lineal \(\mathcal C\). Entonces, \[\mathcal C = \left\{x \in \mathbb F_q^n : xH^T = 0\right\} = \left\{x \in F_q^n : Hx^T = 0\right\}.\]
\end{proposition}

\begin{proof}
  Sea \(c \in \mathcal C\) una palabra codificada. Sabemos que la podemos expresar como \(c = uG\), donde \(u \in \mathbb F_q^k\) y \(G\) es la matriz generadora de \(\mathcal C\). Tenemos entonces que \(c\cramped{H^T} = uG\cramped{H^T}\) y como \(G\cramped{H^T} = 0\) —por ser H matriz generadora del subespacio ortogonal \(\mathcal C\)— se tiene que \[\mathcal C \subset S_H = \left\{x \in \mathbb F_q^n : Hx^T = 0\right\},\] que es el espacio solución de un sistema de \(n - k\) ecuaciones con \(n\) incógnitas y de rango \(n - k\). Como \(\dim(S_H) = n - (n - k) = k = \dim L\), concluimos que \[L = S_H = \left\{x \in \mathbb F_q^n : Hx^T = 0\right\}.\qedhere\]
\end{proof}

El resultado anterior, junto a la definición anterior, nos conducen al siguiente teorema. 

\begin{theorem}
  Si \(G = [I_k \mid A]\) es una matriz generadora para un \([n, k]\) código \(\mathcal C\) en forma estándar entonces \(H = [-A \mid I_{n-k}]\) es una matriz de paridad para \(\mathcal C\).
\end{theorem}

Un código se dice \textit{autoortogonal} cuando \(\mathcal C \subseteq \mathcal C^{\perp}\), y \textit{autodual} cuando \(\mathcal C = \mathcal C^{\perp}\).

\subsection{Distancias y pesos}

\begin{definition}
  La \textit{distancia de Hamming} \(\operatorname{d}(\symbf{x}, \symbf{y})\) entre dos vectores \(\symbf{x}, \symbf{y} \in \mathbb F_q^n\) se define como el número de coordenadas en las que difieren \(\symbf{x}\) e \(\symbf{y}\).
\end{definition}

\begin{theorem}
  La función de distancia \(\operatorname{d}(\symbf{x}, \symbf{y})\) verifica las siguientes propiedades.
  \begin{enumerate}
    \item No negatividad: \(\operatorname{d}(\symbf{x}, \symbf{y}) \geq 0\) para todo \(\symbf{x}, \symbf{y}\in \mathbb F_q^n\).
    \item \(\operatorname{d}(\symbf{x}, \symbf{y}) = 0\) si y solo si \(\symbf{x} = \symbf{y}\).
    \item Simetría: \(\operatorname{d}(\symbf{x}, \symbf{y}) = \operatorname{d}(\symbf{y}, \symbf{x})\) para todo \(\symbf{x}, \symbf{y}\in \mathbb F_q^n\).
    \item Desigualdad triangular: \(\operatorname{d}(\symbf{x}, \symbf{z}) \leq \operatorname{d}(\symbf{x}, \symbf{y}) + \operatorname{d}(\symbf{y}, \symbf{z})\) para todo elemento \(\symbf{x}, \symbf{y}, \symbf{z}\in \mathbb F_q^n\).
  \end{enumerate}
\end{theorem}

La \textit{distancia (mínima)} de un código \(\mathcal C\) es la menor distancia posible entre dos palabras codificadas distintas. 
Es importante a la hora de determinar la capacidad de corrección de errores del código \(\mathcal C\), pues como veremos más tarde, a mayor distancia mínima, mayor número de errores en el código se pueden corregir.

\begin{definition}
  El \textit{peso de Hamming} \(\operatorname{wt}(\symbf{x})\) de un vector \(\symbf{x}\) es el número de coordenadas distintas de cero de \(\symbf{x}\).
\end{definition}

\begin{theorem}
  Si \(\symbf{x}, \symbf{y} \in \mathbb F_q^n\), entonces \(\operatorname{d}(\symbf{x}, \symbf{y}) = \operatorname{wt}(\symbf{x} - \symbf{y})\).
  Si \(\mathcal C\) es un código lineal, la distancia mímina es igual al peso mínimo de las palabras codificadas de \(\mathcal C\) distintas de cero.
\end{theorem}

Como consecuencia de este teorema —para códigos lineales— la distancia mínima también se llama \textit{peso mínimo} del código.
Si el peso mínimo \(d\) de un \([n,k]\) código es conocida, nos referiremos a él como un \([n,k,d]\) código.

\begin{definition}
  Sea \(A_i(\mathcal C)\) —que abreviaremos \(A_i\)— el número de palabras codificadas de peso \(i\) en \(\mathcal C\).
  Para cada \(0 \leq i \leq n\), la lista \(A_i\) se denomina \textit{distribución de peso} o \textit{espectro de peso} de \(\mathcal C\).
\end{definition}

\begin{example}
  Sea \(\mathcal C\) el código binario con matriz generadora
  \[
    G = \begin{pmatrix}
      1 & 1 & 0 & 0 & 0 & 0\\
      0 & 0 & 1 & 1 & 0 & 0 \\
      0 & 0 & 0 & 0 & 1 & 1
    \end{pmatrix}.
  \]
  Dado \((x_1, x_2, x_3)\), se tiene que \[(x_1, x_2, x_3) \begin{pmatrix}
    1 & 1 & 0 & 0 & 0 & 0\\
      0 & 0 & 1 & 1 & 0 & 0 \\
      0 & 0 & 0 & 0 & 1 & 1
  \end{pmatrix} = (x_1, x_1, x_2, x_2, x_3, x_3),\] y por tanto este código codifica de la forma 
  \[
    000 \to 000000, \quad 
    001 \to 000011,\quad 
    010 \to 001100,\quad 
    011 \to 001111,
  \]
  \[
    100 \to 110000, \quad 
    101 \to 110011,\quad 
    110 \to 111100,\quad 
    111 \to 111111.
  \]
  Luego la distribución de peso de \(\mathcal C\) es \(A_0 = A_6 = 1\) y \(A_2 = A_4 = 3\).
  Usualmente solo se listan los \(A_i\) que son distintos de cero.
\end{example}

\begin{theorem}
  Sea \(\mathcal C\) un \([n,k,d]\) código sobre \(\mathbb F_q\).
  Entonces, \begin{enumerate}
    \item \(A_0(\mathcal C) + A_1(\mathcal C) + \cdots + A_n(\mathcal C) = q^k\).
    \item \(A_0(\mathcal C) = 1\) y \(A_1(\mathcal C) = A_2(\mathcal C) = \cdots = A_{d-1}(\mathcal C) = 0\).
  \end{enumerate}
\end{theorem}

% Theorem 1.4.13, Corollary 1.4.14 (Huffman-Pless), p.12-13

\begin{theorem}
  Sea \(\mathcal C\) un código lineal con matriz de paridad \(H\). Si \(\symbf{c} \in \mathcal C\), las columnas de \(H\) que se corresponden con coordenadas no nulas de \(\symbf{c}\) son linealmente independientes.
  Recíprocamente, si entre \(w\) columnas de \(H\) existe una relación de dependencia lineal con coeficientes no nulos, entonces hay una palabra codificada en \(\mathcal C\) de peso \(w\) cuyas coordenadas no nulas se corresponden con dichas columnas.
\end{theorem}

\begin{corollary}
  \label{cor:peso-minimo-columnas-dependientes}
  Un código lineal tiene peso mínimo \(d\) si y solo si su matriz de paridad tiene un conjunto de \(d\) columnas linealmente dependientes pero no tiene un conjunto de \(d-1\) columnas linealmente dependientes.
\end{corollary}

% TODO: teoremas sobre códigos que cumplen ciertas condiciones, no sé si merece Huffman 9-11

\section{Ejemplos de códigos}

\subsection{Códigos de Hamming}

Consideremos una matriz \(r \times (2^r - 1)\) cuyas columnas son los números \(1, 2, 3, \dots, 2^{r-1}\) escritos en binario. 
Dicha matriz es la matriz de paridad de un \([n=2^{r-1}, k=n-r]\) código binario.
A los códigos de esta forma los llamaremos códigos de Hamming de longitud \(n = 2^{r-1}\) y los denotamos por \(\mathcal H_r\) o \(\mathcal H_{2,r}\).

Como las columnas son distintas y no dula, la distancia es al menos \(3\) por el corolario \ref{cor:peso-minimo-columnas-dependientes}.
Además, como las columnas correspondientes a los números \(1, 2, 3\) son linealmente independientes, la distancia mínima es 3 por el mismo corolario.
Podemos decir por tanto que los códigos de Hamming \(\mathcal H_r\) son \([2^{r-1}, 2^{r-1-r}, 3]\) códigos binarios.

Podemos generalizar esta definición y definir los códigos de Hamming \(\mathcal H_{q,r}\) sobre un cuerpo finito arbitrario \(\mathbb F_q\). 
Para \(r \geq 2\) un código \(\mathcal H_{q,r}\) tiene matriz de paridad \(H_{q,r}\), cuyas columnas están compuestas por un vector no nulo por cada uno de los subespacios de dimensión \(1\) de \(\mathbb F_q^r\).
Hay \((q^r-1)/(q-1)\) subespacios de dimensión \(1\), por lo que \(\mathcal H_{q,r}\) tiene longitud \(n = (q^r-1)/(q-1)\), dimensión \(n-r\) y redundancia \(r\).
Como todas las columnas son independientes unas de otras, \(\mathcal H_{q,r}\) tiene peso mínimo al menos 3.
Si sumamos dos vectores no nulos de dos subespacios unidimensionales distintos obtenemos un vector no nulo de un tercer subespacio unidimensional, por lo que \(\mathcal H_{q,r}\) tiene peso mínimo 3. 
Cuando \(q = 2\), \(\mathcal H_{2,r}\) es el código \(\mathcal H_r\).

% TODO
% - por qué los códigos de Hamming son importantes
% - en qué se utilizan los códigos de Hamming

\section{Códigos cíclicos}

Un código lineal \(\mathcal C\) de longitud \(n\) sobre \(\mathbb F_q\) es \textit{cíclico} si para cada vector \(\boldsymbol c = c_0\dotsc_{n-2}c_{n-1}\) en \(\mathcal C\), el vector \(c_{n-1}c_0\dots c_{n-2}\) --obtenido a partir de \(\boldsymbol c\) haciendo desplazando cíclicamente las coordenadas, llevando \(i \mapsto i +1 \bmod n\)-- también está en \(\mathcal C\).
Pensamos en la posición de las coordenadas de forma cíclica, al llegar a \(n -1\) comienzas de nuevo en \(0\).
Al hablar de coordenadas consecutivas siempre tendremos en cuenta esta ciclicidad.

% FIXME: revisar uso palabra "ciclicidad"

Cuando trabajemos con códigos cíclicos representaremos las palabras codificadas como polinomios.
Hay una biyección entre el vector \(\boldsymbol c = c_0c_1\dots c_{n-1}\) en \(\mathbb F_q\) y los polinomios de forma \(c(x) = c_0 + c_1x + \dots c_{n-1}x^{n-1}\) en \(\mathbb F_q[x]\) de grado al menos \(n-1\).
Obsérvese que dado \(c(x)\) descrito como antes, \(xc(x) = c_{n-1}x^n + c_0x + c_1x^2 + \dots + c_{n-2}x^{n-1}\), que equivaldría a representar la palabra codificada \(\boldsymbol c\) desplazada una posición a la derecha si \(x^n\) fuese igual a \(1\).

Formalmente, el hecho de que un código \(\mathcal C\) sea invariante bajo un desplazamiento cíclico implica que si \(c(x)\) está en \(\mathcal C\), también lo está \(xc(x)\), siempre que multipliquemos módulo \(x^n -1\). 
Esto nos sugiere que el contexto para estudiar códigos cíclicos es el anillo cociente \(\mathcal R_n = \mathbb F_q[x]/(x^n - 1)\).

Por tanto, bajo la correspondencia vectores-polinomios que hemos descrito antes, los códigos cíclcos son ideales de \(\mathcal R_n\), y los ideales de \(\mathcal R_n\) son códigos cíclicos.
En consecuencias, el estudio de los códigos cíclicos en \(\mathbb F_q^n\) es equivalente al estudio de los ideales en \(\mathcal R_n\), que depende de la factorización de \(x^n-1\).

\subsection{Factorización de \(x^n -1\)}

Existen dos posibilidades: o bien \(x^n -1\) tiene factores irreducibles repetidos, o no.

Para factorizar \(x^n - 1\) sobre \(\mathbb F_q\) es útil considerar la extensión de cuerpos \(\mathbb F_{q^t}\) de \(\mathbb F_q\) que contenga todas sus raíces.
\(\mathbb F_{q^t}\) debe contener una enésima raíz primitiva de la unidad, que ocurre cuando \(n \mid (q^t - 1)\) por el teorema... 
% TODO: referenciar teorema (Th 3.3.3, ECC)

\subsection{.}

Vamos a ver que hay una correspondencia biyectiva entre los códigos cíclicos en \(\mathcal R_n\) y los polinomios mónicos divisores de \(x^n-1\).

\begin{theorem}
  \label{th:corr-cod-div}
  Sea \(\mathcal C\) un ideal de \(\mathcal R_n\), es decir, un código cíclico de longitud \(n\). Entonces:
  \begin{enumerate}
    \item Existe un único polinomio mónico \(g(x)\) de grado mínimo en \(\mathcal C\).\label{thi:corr-codc-div:monico-minimo}
    \item El polinomio descrito en \ref{thi:corr-codc-div:monico-minimo} genera \(\mathcal C\), es decir, \(\mathcal C = \langle g(x)\rangle\).
    \item El polinomio descrito en \ref{thi:corr-codc-div:monico-minimo} verifica que \(g(x) \mid x^n -1\).\label{thi:corr-codc-div:div-xn-1}
  \end{enumerate}
  Sea \(k = n - \operatorname{gr} g(x)\) y sea \(g(x) = \sum_{i_0}^{n-k}g_ix^{i}\), donde \(g_{n-k} = 1\). Entonces:
  \begin{enumerate}[resume]
    %\item La dimensión de \(\mathcal C\) es \(k\) y \(\{g(x), xg(x), \dots, x^{k-1}g(x)\}\) es una base de \(\mathcal C\).
    %\item Cada elemento de \(\mathcal C\) se puede expresar como producto de \(g(x)\) por un polinomio \(f(x)\), donde \(f(x) = 0\) o bien \(\operatorname{gr} f(x) < k\).
    \item Se verifica que \[
      \mathcal C = \langle g(x) \rangle = \{f(x)g(x) : \operatorname{gr} f(x) < k\}.
    \]\label{thi:corr-codc-div:dim-ideal}
    \item El conjunto \(\{g(x), xg(x), \dots, x^{k-1}g(x)\}\) es una base de \(\mathcal C\) y \(\mathcal C\) tiene dimensión \(k\).
    \item La matriz \(G\) dada por \begin{align*}
      G &= \begin{bmatrix}
        g_0 & g_1 & g_2 & \dots & \dots & g_{n-k} & 0 & 0 & \dots & 0 \\
        0 & g_0 & g_1 & g_2 & \dots & \dots & g_{n-k} & 0 & \dots & 0 \\
        0 & 0 & g_0 & g_1 & g_2 & \dots & \dots & g_r & \ddots & \vdots \\
        \vdots & \vdots & \ddots & \ddots & \ddots & \ddots & & & \ddots & 0\\
        0 & 0 & \dots & 0 & g_0 & g_1 & g_2 & \dots & \dots & g_{n-k} 
      \end{bmatrix},
      % \\
      %   &\iff \begin{bmatrix}
      %     g(x) & & & \\
      %      & xg(x) & & \\
      %      & & \dots & \\
      %      & & & x^{k-1}g(x)
      %   \end{bmatrix}
    \end{align*}
    donde cada fila es un desplazamiento cíclico de la fila previa, es una matriz generadora de \(\mathcal C\).
    \item Si \(\alpha\) es una raíz enésima primitiva de la unidad en alguna extensión de cuerpos de \(\mathbb F_q\) entonces \[
      g(x) = \prod_s M_{\alpha^s}(x),
    \] siendo el producto sobre un subconjunto de representantes de las clases \(q\)-ciclotómicas módulo \(n\).
  \end{enumerate}
\end{theorem}

\begin{proof}
  Veamos la demostración apartado por apartado.
  \begin{enumerate}
    \item Supongamos que \(\mathcal C\) contiene dos polinomios mónicos distintos, \(g_1(x)\) y \(g_2(x)\), de grado mínimo \(r\). 
    Entonces, \(g_1(x) - g_2(x)\) es un polinomio no nulo de grado menor que \(r\), lo que es absurdo. 
    Existe por tanto un único polinomio de grado mínimo \(r\) en \(\mathcal C\), como queríamos.
    \item Como \(g(x) \in \mathcal C\) y \(\mathcal C\) es un ideal, tenemos que \(\langle g(x)\rangle \subset \mathcal C\). 
    Por otra parte, dado \(p(x) \in \mathcal C\) el algoritmo de división nos da elementos \(q(x), r(x)\) tales que \(p(x) = q(x)g(x) + r(x)\), de forma que o bien \(r(x) = 0\) o bien \(\operatorname{gr} r(x) < \operatorname{gr} g(x)\). 
    Como podemos expresar \(r(x)\) de la forma \(r(x) = p(x) - q(x)g(x) \in \mathcal C\) y tiene grado menor que \(\operatorname{gr} g(x)\), al ser este último de grado mínimo necesariamente ha de darse que \(r(x) = 0\).
    Por tanto, \(p(x) = q(x)g(x) \in \langle g(x) \rangle\) y \(\mathcal C \subset \langle g(x) \rangle\).
    En consecuencia, \(\langle g(x) \rangle = \mathcal C\).
    \item Por el algoritmo de división, al dividir \(x^n - 1\) por \(g(x)\) tenemos \(x^n - 1 = q(x)g(x) + r(x)\). De nuevo, o bien \(r(x) = 0\) o bien \(\operatorname{gr} r(x) < \operatorname{gr} g(x)\).
    Como en \(\mathcal R_n\) se tiene que \(x^n - 1 = 0 \in \mathcal C\), necesariamente \(r(x) \in \mathcal C\).
    Esto supone una contradicción, a menos que \(r(x) = 0\).
    % FIXME: por qué supone una contradicción??? mirar 24-2-20 en el cuaderno
    En consecuencia, \(g(x) \mid x^n - 1\).
    \item El ideal generado por \(g(x)\) es \(\langle g(x) \rangle = \{f(x)g(x) : f(x) \in \mathcal R_n\}\).
    Queremos ver que podemos restringir los polinomios \(f(x)\) a aquellos que tengan grado menor que \(k\).
    Por \ref{thi:corr-codc-div:div-xn-1} sabemos que \(x^n-1 = h(x)g(x)\) para algún polinomio \(h(x)\) de grado \(k = n - \operatorname{gr} g(x)\).
    Dividimos entonces \(f(x)\) por este polinomio \(h(x)\) y por el algoritmo de división obtenemos \(f(x) = q(x)h(x) + r(x)\), donde \(\operatorname{gr} r(x) < \operatorname{gr} h(x) = k\).
    Entonces, tenemos \begin{align*}
      f(x)g(x) &= q(x)h(x)g(x) + r(x)g(x)\\
               &= q(x)(x^n - 1) + r(x)g(x),
    \end{align*}
    luego \(f(x)g(x) = r(x)g(x)\), y como ya hemos visto que \(\operatorname{gr} r(x) < k\), tenemos lo que buscábamos.
    \item A partir de (\ref{thi:corr-codc-div:dim-ideal}) tenemos que el conjunto \[\{g(x), xg(x), \dots, x^{k-1}g(x)\}\] genera \(\mathcal C\), y como es linealmente independiente, forma una base de \(\mathcal C\).
    Esto demuestra también que la dimensión de \(\mathcal C\) es \(k\).
    \item La matriz \(G\) es matriz generadora de \(\mathcal C\) pues \[\{g(x), xg(x), \dots, x^{k-1}g(x)\}\] es una base de \(\mathcal C\).
    \item TODO. % TODO: apartado 7, tiene que ver con la factorización de x^n - 1 que todavía no he comentado
  \end{enumerate}
\end{proof}

Este teorema nos muestra que existe un polinomio mónico \(g(x)\) que divide a \(x^n - 1\) y genera \(\mathcal C\).
Vamos a ver a continuación que dicho polinomio es único.

\begin{corollary}
  Sea \(\mathcal C\) un código cíclico en \(\mathcal R_n\) distinto de cero.
  Son equivalentes:
  \begin{enumerate}
    \item El polinomio \(g(x)\) es el polinomio mónico de menor grado en \(\mathcal C\).
    \item Podemos expresar \(\mathcal C\) como \(\mathcal C = \langle g(x)\rangle\), \(g(x)\) es mónico y \(g(x) \mid (x^n -1)\).
  \end{enumerate}
\end{corollary}

\begin{proof}
  Que (1) implica (2) ya lo hemos probado en el teorema \ref{th:corr-cod-div}. 
  Veamos que partiendo de (2) obtenemos (1). 
  Sea \(g_1(x)\) el polinomio mónico de menor grado en \(\mathcal C\).
  Por el teorema \ref{th:corr-cod-div}, \(g_1(x) \mid g(x)\) en \(\mathbb F_q[x]\) y \(\mathcal C = \langle g_1(x)\rangle\).
  Como \(g_1(x) \in \mathcal C = \langle g(x) \rangle\), podemos expresar \(g_1(x) = g(x)a(x) \bmod x^n - 1\), luego tenemos que \(g_1(x) = g(x)a(x) + (x^n - 1)b(x)\) en \(\mathbb F_q[x]\).
  Por otro lado, como \(g(x) \mid (x^n - 1)\), tenemos que \(g(x) \mid g(x)a(x) + (x^n-1)b(x)\), o lo que es lo mismo, que \(g(x) \mid g_1(x)\). 
  En consecuencia, como \(g_1(x)\) y \(g(x)\) son ambos mónicos y dividen el uno al otro en \(\mathbb F_q[x]\), son necesariamente iguales.
\end{proof}

A este polinomio lo llamamos \textit{polinomio generador} del código cíclico \(\mathcal C\).
Por el corolario anterior, este polinomio es tanto el polinomio mónico en \(\mathcal C\) de grado mínimo como el polinomio mónico que divide a \(x^n - 1\) y genera a \(\mathcal C\).
Existe por tanto una correspondencia biunívoca entre los códigos cíclicos distintos de cero y los divisores de \(x^n - 1\) distintos de \(x^n - 1\).
Para extender dicha correspondencia entre todos los códigos cíclicos en \(\mathcal R_n\) y todos los divisores mónicos de \(x^n - 1\) definimos como polinomio generador del código cíclico \(\{\boldsymbol 0\}\) el polinomio \(x^n - 1\). 
Esta correspondencia biyectiva nos conduce al siguiente corolario.

\begin{corollary}
  El número de códigos cíclicos en \(\mathcal R_n\) es \(2^m\), donde \(m\) es el número de clases \(q\)-ciclotómicas módulo \(n\).
  Es más, las dimensiones de los códigos cíclicos en \(\mathcal R_n\) son todas sumas de tamaños de las clases \(q\)-ciclotómicas módulo \(n\).
\end{corollary}

\begin{proof}
  % TODO: demostrar? en el libro no viene demostrado y tampoco entiendo muy bien la segunda afirmación
\end{proof}

% TODO: ejemplo? ejemplo 4.2.4 del libro

El siguiente resultado nos muestra la relación entre dos polinomios generadores cuando un código es subcódigo de otro.

\begin{corollary}
  Sean \(\mathcal C_1\) y \(\mathcal C_2\) códigos cíclicos sobre \(\mathbb F_q\) con polinomios generadores \(g_1(x)\) y \(g_2(x)\), respectivamente.
  Entonces, \(\mathcal C_1 \subset \mathcal C_2 \) si y solo si \(g_2(x) \mid g_1(x)\).
\end{corollary}

% TODO: resultados sobre duales de códigos cíclicos (4.2.6, 4.2.7)

\subsection{Codificación y decodificación de códigos cíclicos}

Los códigos cíclicos son más sencillos de decodificar que otros tipos de códigos debido a su estructura adicional.
Vamos a ver a continuación tres tipos de codificación de códigos cíclicos.
Consideraremos un código cíclico \(\mathcal C\) de longitud \(n\) sobre \(\mathbb F_q\) con polinomio generador \(g(x)\) de grado \(n - k\), por lo que \(\mathcal C\) tiene dimensión \(k\).

\paragraph{Codificación no-sistemática}

Esta forma de codificación está basada en la técnica natural de codificación que describimos en la sección (
  %TODO: referencia
).
Sea \(G\) la matriz generadora obtenida a partir de los desplazamientos de \(g(x)\) descrita en el teorema \ref{th:corr-cod-div}.
Dado el mensaje \(\mathbf m \in \mathbb F_q^k\), lo codificamos como la palabra codificada \(\mathbf c = \mathbf mG\).
De igual forma, si \(m(x)\) y \(c(x)\) son los polinomios en \(\mathbb F_q[x]\) asociados a \(\mathbf{m}\) y \(\mathbf c\), entonces \(c(x) = m(x)g(x)\).

\paragraph{Codificación sistemática}

En este método, dado un mensaje 

\paragraph{Codificación sistemática usando el código dual}

\begin{example}
  Sea \(\mathcal C\) un código cíclico de longitud 15 con polinomio generador \(g(x) = (1 + x + x^4)(1 + x + x^2 + x^3 + x^4)\). Vamos a ver su codificación con los tres métodos descritos.
\end{example}

\section{Algoritmo de Peterson-Gorenstein-Zierler}